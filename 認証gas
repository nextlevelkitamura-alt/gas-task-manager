/**
 * ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®ã‚¿ã‚¹ã‚¯ç®¡ç†ï¼†ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆè‡ªå‹•ä½œæˆã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆæœ€çµ‚çµ±åˆç‰ˆï¼‰
 * Version: 2.0.0
 * 
 * * ã€æ©Ÿèƒ½ä¸€è¦§ã€‘
 * 1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§ã‚·ãƒ¼ãƒˆã®Aåˆ—ã«å…¥åŠ› -> è¨­å®šã‚·ãƒ¼ãƒˆå·¦å´ã«ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¦æ–°ã‚·ãƒ¼ãƒˆä½œæˆ
 * 2. ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆ(5è¡Œç›®~)ãŠã‚ˆã³å„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆ(29è¡Œç›®~)ã®Cåˆ—ã«å…¥åŠ› -> IDè‡ªå‹•ç”Ÿæˆ
 * 3. ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã®Aåˆ—(å®Œäº†)ã‚’ON -> ã€Œå®Œäº†ã‚¿ã‚¹ã‚¯ã€ã‚·ãƒ¼ãƒˆã¸ç§»å‹•
 * 4. å„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã®Aåˆ—(å®Œäº†)ã‚’ON -> åŒã‚·ãƒ¼ãƒˆå†…ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚¨ãƒªã‚¢ã¸ç§»å‹•
 * 5. ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã®F3ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ON -> ã€çµ±åˆæ©Ÿèƒ½ã€‘åŒæœŸãƒ»è»¢é€ãƒ»ä¸¦ã³æ›¿ãˆã‚’ä¸€æ‹¬å®Ÿè¡Œ
 * 6. å€‹åˆ¥ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã§E2ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ON -> ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸ ï¼† ä¸¦ã³æ›¿ãˆ
 * 7. ã€Œã‚¿ã‚¹ã‚¯ä¸€è¦§ã€ã‚·ãƒ¼ãƒˆã®D1ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ON -> ã€çµ±åˆæ©Ÿèƒ½ã€‘ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åæ˜ å¾Œã«ç›´è¿‘ã‚¿ã‚¹ã‚¯ã‚’é›†è¨ˆãƒ»æ›´æ–°
 * 8. ã€èªè¨¼æ©Ÿèƒ½ã€‘Webã‚¢ãƒ—ãƒªã¨ã—ã¦ãƒ‡ãƒ—ãƒ­ã‚¤æ™‚ã€ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ã‚ˆã‚‹èªè¨¼åˆ¶é™ (é–€ç•ªæ©Ÿèƒ½)
 * 9. ã€ä¿å®ˆæ©Ÿèƒ½ã€‘è¨­å®šè¨ºæ–­ & ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ä¿®å¾©
 */

// ==========================================
// 1. èªè¨¼é–€ç•ªã‚·ã‚¹ãƒ†ãƒ ï¼ˆWebã‚¢ãƒ—ãƒªç”¨ï¼‰
// ==========================================

/**
 * å¤–éƒ¨ã‹ã‚‰ã®èªè¨¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ã‘å–ã‚‹ï¼ˆâ–¶å®Ÿè¡Œãƒœã‚¿ãƒ³ã¯æŠ¼ã—ã¡ã‚ƒãƒ€ãƒ¡ï¼ï¼‰
 */
function doGet(e) {
  // â˜…é‡è¦: ã‚¨ãƒ‡ã‚£ã‚¿ã®ã€Œå®Ÿè¡Œã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ãŸã¨ãã®å¯¾ç­–
  if (!e) {
    return ContentService.createTextOutput("ã€ã‚¨ãƒ©ãƒ¼ã€‘ã“ã®é–¢æ•°ã¯ã€Œã‚¦ã‚§ãƒ–ã‚¢ãƒ—ãƒªã€ã¨ã—ã¦ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¦ä½¿ã†ã‚‚ã®ã§ã™ã€‚ã“ã“ã§ã®å®Ÿè¡Œãƒœã‚¿ãƒ³ã§ã¯å‹•ä½œã—ã¾ã›ã‚“ã€‚");
  }

  const userEmail = e.parameter ? e.parameter.email : null;
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName("èªè¨¼ãƒªã‚¹ãƒˆ"); // ã‚·ãƒ¼ãƒˆåãŒç”»åƒã¨ä¸€è‡´ã—ã¦ã„ã‚‹ã“ã¨
  
  if (!sheet) {
    return ContentService.createTextOutput("Error: 'èªè¨¼ãƒªã‚¹ãƒˆ' sheet not found");
  }
  
  // 1è¡Œç›®ï¼ˆè¦‹å‡ºã—ï¼‰ã‚’é£›ã°ã—ã€2è¡Œç›®ä»¥é™ã®ã€ŒCåˆ—ï¼ˆ3åˆ—ç›®ï¼‰ã€ã‚’ã™ã¹ã¦å–å¾—
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return ContentService.createTextOutput("NG");
  
  const authEmails = sheet.getRange(2, 3, lastRow - 1, 1).getValues().flat();

  // å®Ÿéš›ã«ãƒ„ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦ã„ã‚‹äººã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹åˆ¤å®š
  const isAllowed = authEmails.includes(userEmail);
  return ContentService.createTextOutput(isAllowed ? "OK" : "NG");
}

// ==========================================
// 2. å®šæ•°ãƒ»è¨­å®š
// ==========================================

const VERSION = '2.0.0';

// --- è¨­å®šå€¤ ---
const PROJECT_SHEET_NAME = 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§';
const TEMPLATE_SHEET_NAME = 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ';
const TASK_SHEET_NAME = 'ã‚¿ã‚¹ã‚¯å…¥åŠ›';
const SETTING_SHEET_NAME = 'è¨­å®š';
const COMPLETED_SHEET_NAME = 'å®Œäº†ã‚¿ã‚¹ã‚¯';
const RECENT_TASK_SHEET_NAME = 'ã‚¿ã‚¹ã‚¯ä¸€è¦§';
const CALENDAR_INBOX_SHEET_NAME = 'ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼';
const GAS_MANAGE_SHEET_NAME = 'gasç®¡ç†';


// ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆè¨­å®š
const TASK_START_ROW = 5;   // ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã®å…¥åŠ›é–‹å§‹è¡Œ
const PROJECT_TASK_START_ROW = 29; // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã®ã‚¿ã‚¹ã‚¯é–‹å§‹è¡Œ
 
const COL_TASK_NAME = 2;    // Båˆ—
const COL_START_TIME = 3;   // Cåˆ—
const COL_PRIORITY = 4;     // Dåˆ—
const COL_DURATION = 5;     // Eåˆ—
const COL_PROJECT_NAME = 6; // Fåˆ—
// const COL_TAG = 7;       // Gåˆ—
const COL_MEMO = 8;         // Håˆ— (å®Ÿãƒ‡ãƒ¼ã‚¿ã¯ã“ã“)
const COL_CAL_TYPE = 9;     // Iåˆ—
const COL_EVENT_ID = 10;    // Jåˆ—
const COL_TASK_ID = 11;     // Kåˆ—
 
// ã‚¨ãƒªã‚¢å®šç¾©
const TASK_AREA_LAST_COL = 12; // Låˆ—ã¾ã§ç¢ºä¿
const ARCHIVE_START_ROW = 29;  // ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–é–‹å§‹è¡Œ
const ARCHIVE_START_COL = 13;  // Måˆ—ã‹ã‚‰ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–
 
// ã‚¹ãƒãƒ›æ“ä½œç”¨ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ä½ç½®
const SYNC_CHECKBOX_CELL = 'E2';        // ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆç”¨
const EXECUTE_ALL_CHECKBOX_CELL = 'A3'; // ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆç”¨
const PROJECT_SYNC_SORT_CELL = 'A27';   // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆç”¨
const DASHBOARD_INTEGRATED_CHECKBOX_CELL = 'D1'; // ã‚¿ã‚¹ã‚¯ä¸€è¦§ã‚·ãƒ¼ãƒˆç”¨
const CALENDAR_IMPORT_CHECKBOX_CELL = 'F1';  // ã‚¿ã‚¹ã‚¯ä¸€è¦§ã‚·ãƒ¼ãƒˆç”¨

// è¨­å®šã‚·ãƒ¼ãƒˆåˆ—å®šç¾©
const SETTINGS_NAME_COL = 2;
const SETTINGS_ID_COL = 3;
const SETTINGS_DURATION_COL = 5; // Eåˆ—: æ‰€è¦æ™‚é–“ãƒªã‚¹ãƒˆ

// å‡¦ç†ã‹ã‚‰é™¤å¤–ã™ã‚‹ã‚·ãƒ¼ãƒˆåãƒªã‚¹ãƒˆ
const EXCLUDED_SHEETS = [
  PROJECT_SHEET_NAME, 
  TEMPLATE_SHEET_NAME, 
  TASK_SHEET_NAME, 
  SETTING_SHEET_NAME, 
  COMPLETED_SHEET_NAME,
  RECENT_TASK_SHEET_NAME,
  CALENDAR_INBOX_SHEET_NAME,
  GAS_MANAGE_SHEET_NAME,

];

// ==========================================
// 3. ãƒ¡ãƒ‹ãƒ¥ãƒ¼ & ãƒˆãƒªã‚¬ãƒ¼
// ==========================================

/**
 * ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¿½åŠ  (çµ±åˆç‰ˆ)
 */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('ğŸ“… ã‚¿ã‚¹ã‚¯é€£æº')
    .addItem('è¨­å®š: è‡ªå‹•åŒ–ãƒˆãƒªã‚¬ãƒ¼ã‚’ã‚»ãƒƒãƒˆ (æ›´æ–°æ™‚ã‚‚å®Ÿè¡Œ)', 'setupTriggers')
    .addItem('ğŸ”§ è¨­å®šãƒã‚§ãƒƒã‚¯ (åˆæœŸè¨ºæ–­)', 'checkConfiguration')
    .addSeparator()
    .addItem('æ‰‹å‹•: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆä½œæˆ', 'createProjectSheets')
    .addItem('æ‰‹å‹•: ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸ (ã‚¿ã‚¹ã‚¯å…¥åŠ›)', 'syncTasksToCalendar')
    .addItem('æ‰‹å‹•: ã€çµ±åˆã€‘åŒæœŸãƒ»è»¢é€ãƒ»ä¸¦ã³æ›¿ãˆ (ã‚¿ã‚¹ã‚¯å…¥åŠ›)', 'executeTasksAction')
    .addItem('æ‰‹å‹•: ã‚¿ã‚¹ã‚¯ä¸€è¦§æ›´æ–° (çµ±åˆç‰ˆ)', 'updateDashboardWithCalendarSync')
    .addSeparator()
    .addItem('ğŸ”§ ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆä¿®å¾© (ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹å†è¨­ç½®)', 'repairCheckboxes')

    .addToUi();
}

// â˜… Web App URL (Moved from Distribution Script)
const AUTH_URL = "https://script.google.com/macros/s/AKfycbymabLBIHrbYwxlICC2IYxTStaK7XJ6RFUB4AP1fHqRj83d7gchtQlMfkBVOtSAFX2dOw/exec";

function checkUserPermission(silent = false) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();

  // 1. Developer Mode: Running on Master Spreadsheet (Bypass Web Auth)
  const MASTER_SS_ID = '1swzEa8VRMWgTO69LztBMc32lAmOx_Pu_4wLErhDhALM';
  if (ss.getId() === MASTER_SS_ID) {
    const authSheet = ss.getSheetByName("èªè¨¼ãƒªã‚¹ãƒˆ");
    if (authSheet) {
      const userEmail = Session.getActiveUser().getEmail();
      const effectiveEmail = Session.getEffectiveUser().getEmail();
      const lastRow = authSheet.getLastRow();
      
      if (lastRow >= 2) {
        const authList = authSheet.getRange(2, 3, lastRow - 1, 1).getValues().flat();
        if (authList.includes(userEmail) || authList.includes(effectiveEmail)) {
          return true;
        }
      }
    }
  }

  // 2. User Mode: Check 7-Day Cache
  // ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå´ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å‚ç…§ã™ã‚‹ãŸã‚ã€é…å¸ƒãƒ¦ãƒ¼ã‚¶ãƒ¼å´ã§æ”¹ç«„ä¸å¯
  const userProperties = PropertiesService.getUserProperties();
  const cachedStatus = userProperties.getProperty('AUTH_CACHE');
  const lastChecked = userProperties.getProperty('AUTH_DATE');
  const now = new Date().getTime();
  const ONE_WEEK_MS = 7 * 24 * 60 * 60 * 1000;

  if (cachedStatus === 'OK' && lastChecked && (now - Number(lastChecked) < ONE_WEEK_MS)) {
    return true; // Valid Cache
  }

  // 3. Cache Expired/Missing: Verify via Web App
  try {
     const userEmail = Session.getActiveUser().getEmail();
     const response = UrlFetchApp.fetch(AUTH_URL + "?email=" + userEmail);
     
     if (response.getContentText() === "OK") {
        // Success: Update Cache
        userProperties.setProperty('AUTH_CACHE', 'OK');
        userProperties.setProperty('AUTH_DATE', now.toString());
        return true;
     } else {
        // Failure: Clear Cache
        userProperties.deleteProperty('AUTH_CACHE');
        userProperties.deleteProperty('AUTH_DATE');
     }
  } catch(e) {
     console.warn("Auth check failed", e);
  }

  // 4. Access Denied
  if (!silent) {
    const ui = SpreadsheetApp.getUi();
    try {
      const userEmail = Session.getActiveUser().getEmail();
      ui.alert("èªè¨¼ã‚¨ãƒ©ãƒ¼", `ã‚ãªãŸã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ (${userEmail}) ã«ã¯ä½¿ç”¨æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚\nè‡ªå‹•èªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ç®¡ç†è€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚`, ui.ButtonSet.OK);
    } catch(e) {}
  }
  
  return false;
}

/**
 * ã€é‡è¦ã€‘ãƒˆãƒªã‚¬ãƒ¼è¨­å®šç”¨é–¢æ•° (çµ±åˆç‰ˆ)
 */
function setupTriggers() {
  if (!checkUserPermission()) return; // æ¨©é™ãƒã‚§ãƒƒã‚¯

  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(t => ScriptApp.deleteTrigger(t));

  // 1. ç·¨é›†æ™‚ãƒˆãƒªã‚¬ãƒ¼ï¼ˆæ‰‹å‹•æ“ä½œç”¨ï¼‰
  ScriptApp.newTrigger('onEditTrigger')
    .forSpreadsheet(SpreadsheetApp.getActive())
    .onEdit()
    .create();

  // 2. ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸï¼ˆã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ -> ã‚·ãƒ¼ãƒˆï¼‰: 15åˆ†ã”ã¨
  ScriptApp.newTrigger('syncFromCalendarToSheets')
    .timeBased()
    .everyMinutes(15)
    .create();

  // 3. ã‚¿ã‚¹ã‚¯ä¸€è¦§æ›´æ–°ï¼ˆãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æœ€æ–°åŒ–ï¼‰: 1æ™‚é–“ã”ã¨
  ScriptApp.newTrigger('updateDashboard')
    .timeBased()
    .everyHours(1)
    .create();

  // 4. ã‚¿ã‚¹ã‚¯è»¢è¨˜ãƒ»æ•´ç†ï¼ˆã‚¿ã‚¹ã‚¯å…¥åŠ› -> ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆï¼‰: æ¯æ—¥ æ·±å¤œ3æ™‚
  ScriptApp.newTrigger('executeTasksAction')
    .timeBased()
    .atHour(3)
    .everyDays(1)
    .create();

  // 5. ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆä¿®å¾©: æ¯æ—¥ (ã“ã“ã«è¿½åŠ )
  // è‡ªå‹•ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ã¨ã—ã¦æ¯æ—¥æ—©æœã«å®Ÿè¡Œã™ã‚‹ã¨å®‰å¿ƒã§ã™
  ScriptApp.newTrigger('repairCheckboxes')
    .timeBased()
    .atHour(4)
    .everyDays(1)
    .create();

  // åˆæœŸè¨­å®šæ™‚ã«ã‚‚ä¸€åº¦å®Ÿè¡Œã—ã¦ãŠã
  repairCheckboxes();

  Browser.msgBox('è¨­å®šå®Œäº†ï¼\nãƒ»ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸ: 15åˆ†ã”ã¨\nãƒ»ã‚¿ã‚¹ã‚¯ä¸€è¦§æ›´æ–°: 1æ™‚é–“ã”ã¨\nãƒ»ã‚¿ã‚¹ã‚¯è»¢è¨˜: æ¯æ—¥3æ™‚\nãƒ»ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆä¿®å¾©: æ¯æ—¥4æ™‚\nã«è¨­å®šã—ã¾ã—ãŸã€‚');
}

/**
 * ã€æ–°è¦ã€‘è¨­å®šè¨ºæ–­ãƒ„ãƒ¼ãƒ«
 */
function checkConfiguration() {
  if (!checkUserPermission()) return; // æ¨©é™ãƒã‚§ãƒƒã‚¯
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const results = [];
  let errorCount = 0;

  // 1. ã‚·ãƒ¼ãƒˆå­˜åœ¨ãƒã‚§ãƒƒã‚¯
  const sheetsToCheck = [PROJECT_SHEET_NAME, TEMPLATE_SHEET_NAME, TASK_SHEET_NAME, SETTING_SHEET_NAME, COMPLETED_SHEET_NAME];
  sheetsToCheck.forEach(name => {
    if (ss.getSheetByName(name)) {
      results.push(`âœ… ã‚·ãƒ¼ãƒˆOK: ${name}`);
    } else {
      results.push(`âŒ ã‚·ãƒ¼ãƒˆä¸è¶³: ${name} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚åå‰ã‚’å¤‰ãˆãŸã‹å‰Šé™¤ã—ã¦ã„ã¾ã›ã‚“ã‹ï¼Ÿ`);
      errorCount++;
    }
  });

  // 2. è¨­å®šã‚·ãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
  const settingInfo = ss.getSheetByName(SETTING_SHEET_NAME);
  if (settingInfo) {
    const calData = settingInfo.getRange(2, 1, settingInfo.getLastRow(), 3).getValues();
    const hasCalendar = calData.some(r => r[1] && r[1].includes('@') || r[1].includes('calendar'));
    if (hasCalendar) {
      results.push(`âœ… ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼è¨­å®š: å°‘ãªãã¨ã‚‚1ã¤ã®ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ`);
    } else {
      results.push(`âš  ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æœªè¨­å®š: è¨­å®šã‚·ãƒ¼ãƒˆã«ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼IDãŒå…¥åŠ›ã•ã‚Œã¦ã„ãªã„ã‚ˆã†ã§ã™`);
    }
  }

  // 3. èªè¨¼ãƒªã‚¹ãƒˆãƒã‚§ãƒƒã‚¯
  if (ss.getSheetByName("èªè¨¼ãƒªã‚¹ãƒˆ")) {
     results.push(`âœ… èªè¨¼ãƒªã‚¹ãƒˆ: Webã‚¢ãƒ—ãƒªä½¿ç”¨æ™‚ã«å¿…è¦ãªã€Œèªè¨¼ãƒªã‚¹ãƒˆã€ã‚·ãƒ¼ãƒˆãŒã‚ã‚Šã¾ã™`);
  } else {
     results.push(`âš  èªè¨¼ãƒªã‚¹ãƒˆãªã—: ã“ã®ã¾ã¾ã§ã¯Webã‚¢ãƒ—ãƒªæ©Ÿèƒ½ï¼ˆé–€ç•ªï¼‰ãŒå‹•ä½œã—ã¾ã›ã‚“`);
  }

  const msg = results.join('\\n');
  if (errorCount === 0) {
    Browser.msgBox('è¨ºæ–­çµæœ: æ­£å¸¸', msg, Browser.Buttons.OK);
  } else {
    Browser.msgBox('è¨ºæ–­çµæœ: ã‚¨ãƒ©ãƒ¼ã‚ã‚Š', msg, Browser.Buttons.OK);
  }
}

/**
 * ç·¨é›†æ™‚ã«å‘¼ã°ã‚Œã‚‹çµ±åˆé–¢æ•°
 */
function onEditTrigger(e) {
  if (!checkUserPermission(true)) return; // æ¨©é™ãƒã‚§ãƒƒã‚¯ (ç·¨é›†æ™‚ã¯ã†ã‚‹ã•ã„ã®ã§silent=trueæ¨å¥¨ã ãŒã€æ‰‹å‹•æ“ä½œã¯å¼¾ããŸã„ã®ã§falseã«ã™ã‚‹ã‹è¦æ¤œè¨)
  // ãŸã ã— onEdit ã¯é »ç¹ã«èµ°ã‚‹ã®ã§ silent=true ã«ã—ã¦ã€ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°ã«æ®‹ã™å½¢ãŒä¸€èˆ¬çš„ã€‚
  // ã—ã‹ã—ãƒ¦ãƒ¼ã‚¶ãƒ¼è¦æœ›ã¯ã€Œå…¨ãä½¿ãˆãªã„ã‚ˆã†ã«ã€ãªã®ã§ã€ã‚¢ãƒ©ãƒ¼ãƒˆãŒå‡ºã¦ã‚‚è‰¯ã„å ´é¢ï¼ˆæ‰‹å‹•ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ï¼‰ãŒå¤šã„ã€‚
  // ç·¨é›†æ™‚ãƒˆãƒªã‚¬ãƒ¼ã¯ UIæ“ä½œãŒã§ããªã„(alertå‡ºã›ãªã„)ã‚±ãƒ¼ã‚¹ãŒå¤šã„ã®ã§ silent=true ã«ã—ã¤ã¤ã€å‡¦ç†ã‚’æŠœã‘ã‚‹ã®ãŒå®‰å…¨ã€‚
  // ã“ã“ã§ã¯ silent=true ã§å®Ÿè£…ã™ã‚‹ã€‚

  if (!e) return;

  const range = e.range;
  const sheet = range.getSheet();
  const sheetName = sheet.getName();
  const row = range.getRow();
  const col = range.getColumn();
  const val = range.getValue();
  const a1 = range.getA1Notation();

  // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®åˆ¤å®šã‚’ç·©ã‚ã‚‹ (TRUE, true, 1 ãªã©ã«å¯¾å¿œ)
  const isChecked = (val === true || val === 'TRUE' || val === 1);

  // --- ã‚¿ã‚¹ã‚¯ä¸€è¦§(ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰)ã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† ---
  if (sheetName === RECENT_TASK_SHEET_NAME) {
    // å®Œäº†ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ (Aåˆ—)
    if (col === 1 && isChecked && row >= 3) {
      completeTaskFromDashboard(sheet, row); // é«˜é€Ÿå®Œäº†å‡¦ç†
      return;
    }

    if (a1 === DASHBOARD_INTEGRATED_CHECKBOX_CELL && isChecked) {
      SpreadsheetApp.getActiveSpreadsheet().toast('åŒæ–¹å‘åŒæœŸã‚’é–‹å§‹ã—ã¾ã™...', 'å‡¦ç†ä¸­');
      try {
        ensureSheetColumns(sheet, 19);  // åˆ—æ•°å¢—åŠ ã«å¯¾å¿œ
        reflectDashboardChanges(); // å¤‰æ›´åæ˜ 
        processUnscheduledTasks(); // æœªè¨­å®šã‚¿ã‚¹ã‚¯ç™»éŒ²
        syncFromCalendarToSheets(); // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åæ˜ 
        updateDashboard(); // å†é›†è¨ˆ
      }
      catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
      finally { range.setValue(false); }
      return;
    }
    if (a1 === CALENDAR_IMPORT_CHECKBOX_CELL && isChecked) {
      SpreadsheetApp.getActiveSpreadsheet().toast('ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®æ—¥æ™‚å¤‰æ›´ã‚’åæ˜ ä¸­...', 'å‡¦ç†ä¸­');
      try { syncFromCalendarToSheets(); }
      catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
      finally { range.setValue(false); }
      return;
    }
  }

  // --- å€‹åˆ¥ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† ---
  if (!EXCLUDED_SHEETS.includes(sheetName)) {
    // åŒæœŸãƒœã‚¿ãƒ³ A27
    if (a1 === 'A27' && isChecked) {
      SpreadsheetApp.getActiveSpreadsheet().toast('ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸã¨ä¸¦ã³æ›¿ãˆã‚’å®Ÿè¡Œä¸­...', 'å‡¦ç†ä¸­');
      try { syncAndSortProjectSheet(sheet); } 
      catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); } 
      finally { range.setValue(false); }
      return;
    }
    // å®Œäº†ãƒã‚§ãƒƒã‚¯ (Aåˆ—) -> ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ç§»å‹•
    if (col === 1 && isChecked && row >= PROJECT_TASK_START_ROW) {
      // ã€ä¿®æ­£ã€‘ã‚¿ã‚¹ã‚¯åãŒãªã‘ã‚Œã°å³è§£é™¤ã—ã¦ä½•ã‚‚ã—ãªã„
      const tName = sheet.getRange(row, COL_TASK_NAME).getValue();
      if (!tName) {
        range.setValue(false);
        return;
      }
      archiveCompletedTask(sheet, row);
      return;
    }
    // IDè‡ªå‹•ç”Ÿæˆ (Cåˆ—)
    // ã€ä¿®æ­£ã€‘å€¤(val)ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿ç”Ÿæˆ (ç©ºæ–‡å­—ã§åå¿œã—ãªã„ã‚ˆã†ã«)
    if (col === COL_TASK_NAME && val && String(val).trim() !== '' && row >= PROJECT_TASK_START_ROW) {
      const idCell = sheet.getRange(row, COL_TASK_ID);
      if (!idCell.getValue()) idCell.setValue(Utilities.getUuid().split('-')[0]);
    }
    return;
  }

  // --- ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† ---
  if (sheetName === TASK_SHEET_NAME) {
    // å®Œäº†ãƒã‚§ãƒƒã‚¯ (Aåˆ—) -> å®Œäº†ã‚¿ã‚¹ã‚¯ã‚·ãƒ¼ãƒˆã¸ç§»å‹•
    if (col === 1 && isChecked && row >= TASK_START_ROW) {
      moveTaskToCompletedSheet(sheet, row);
      return;
    }
    // å˜ä½“åŒæœŸ
    if (a1 === SYNC_CHECKBOX_CELL && isChecked) {
      SpreadsheetApp.getActiveSpreadsheet().toast('ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸã‚’é–‹å§‹ã—ã¾ã™...', 'å‡¦ç†ä¸­');
      try { syncTasksToCalendar(); } finally { range.setValue(false); }
      return;
    }
    // A3: ã€çµ±åˆæ©Ÿèƒ½ã€‘åŒæœŸãƒ»è»¢é€ãƒ»ä¸¦ã³æ›¿ãˆ
    if (a1 === 'A3' && isChecked) {
      SpreadsheetApp.getActiveSpreadsheet().toast('å…¨å‡¦ç†ã‚’ä¸€æ‹¬å®Ÿè¡Œä¸­...\n(åŒæœŸãƒ»è»¢é€ãƒ»ä¸¦ã³æ›¿ãˆ)', 'å‡¦ç†ä¸­');
      try { executeTasksAction(); } 
      catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
      finally { range.setValue(false); }
      return;
    }
    // IDç”Ÿæˆ
    // ã€ä¿®æ­£ã€‘å€¤(val)ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿ç”Ÿæˆ
    if (col === COL_TASK_NAME && val && String(val).trim() !== '' && row >= TASK_START_ROW) {
      const idCell = sheet.getRange(row, COL_TASK_ID);
      if (!idCell.getValue()) idCell.setValue(Utilities.getUuid().split('-')[0]);
    }
  }

  // --- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§ã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† ---
  if (sheetName === PROJECT_SHEET_NAME && col === 1 && row >= 2 && val) {
    const projectName = String(val).trim();
    if (projectName && !SpreadsheetApp.getActiveSpreadsheet().getSheetByName(projectName)) {
      createNewSheet(projectName);
    }
  }

  // --- è¨­å®šã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† (ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼) ---
  if (sheetName === SETTING_SHEET_NAME) {
    // Aåˆ—ãƒã‚§ãƒƒã‚¯ -> ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼å®Ÿè¡Œ (è¡Œã”ã¨ã«åˆ¤å®š)
    if (col === 1 && isChecked && row >= 2) {
      SpreadsheetApp.getActiveSpreadsheet().toast('ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼ã‚’é–‹å§‹ã—ã¾ã™...', 'å‡¦ç†ä¸­');
      try { importCalendarToInbox(sheet, row); }
      catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
      finally { range.setValue(false); }
      return;
    }
  }

  // --- ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼ã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† (æŒ¯ã‚Šåˆ†ã‘å®Ÿè¡Œ) ---
  if (sheetName === CALENDAR_INBOX_SHEET_NAME) {
     // A3: æŒ¯ã‚Šåˆ†ã‘é–‹å§‹ (ãƒ¦ãƒ¼ã‚¶ãƒ¼è¦æœ›ã«ã‚ˆã‚ŠA3ã«å¤‰æ›´)
     if (a1 === 'A3' && isChecked) {
       SpreadsheetApp.getActiveSpreadsheet().toast('ã‚¿ã‚¹ã‚¯ã®æŒ¯ã‚Šåˆ†ã‘ãƒ»è»¢é€ã‚’é–‹å§‹ã—ã¾ã™...', 'å‡¦ç†ä¸­');
       try { distributeInboxTasks(); }
       catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
       finally { range.setValue(false); }
       return;
     }
  }


}

/**
 * æ‰‹å‹•å®Ÿè¡Œç”¨ãƒ©ãƒƒãƒ‘ãƒ¼é–¢æ•°
 */
function updateDashboardWithCalendarSync() {
  if (!checkUserPermission()) return; // æ¨©é™ãƒã‚§ãƒƒã‚¯
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(RECENT_TASK_SHEET_NAME);
  if (!sheet) return;
  
  sheet.getRange(DASHBOARD_INTEGRATED_CHECKBOX_CELL).setValue(true);
  ss.toast('å…¨ã‚·ãƒ¼ãƒˆã®ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸãƒ»é›†è¨ˆã‚’é–‹å§‹ã—ã¾ã™...', 'å‡¦ç†ä¸­');
  try {
    ensureSheetColumns(sheet, 18);
    reflectDashboardChanges();
    processUnscheduledTasks();
    syncFromCalendarToSheets();
    updateDashboard();
  }
  catch (err) { console.error(err); ss.toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
  finally { sheet.getRange(DASHBOARD_INTEGRATED_CHECKBOX_CELL).setValue(false); }
}

/**
 * ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°: æŒ‡å®šã—ãŸåˆ—æ•°ã«ãªã‚‹ã‚ˆã†ã«ã‚·ãƒ¼ãƒˆã‚’æ‹¡å¼µã™ã‚‹
 */
function ensureSheetColumns(sheet, requiredCols) {
  const currentCols = sheet.getMaxColumns();
  if (currentCols < requiredCols) {
    sheet.insertColumnsAfter(currentCols, requiredCols - currentCols);
  }
}

/**
 * ã€æ–°è¦ã€‘å³å´(æœªå®š)ãƒªã‚¹ãƒˆã§æ—¥æ™‚ãŒå…¥åŠ›ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚’ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ç™»éŒ²ã—ã€å…ƒã‚·ãƒ¼ãƒˆã¸åæ˜ 
 */
function processUnscheduledTasks() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(RECENT_TASK_SHEET_NAME);
  if (!dashboardSheet) return;

  const lastRow = dashboardSheet.getLastRow();
  if (lastRow < 3) return;

  ensureSheetColumns(dashboardSheet, 18);

  // Fetch L(12) ~ V(22) -> 11 columns
  const range = dashboardSheet.getRange(3, 12, lastRow - 2, 11);
  const values = range.getValues();
  
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  const calendarMap = getCalendarMap(settingsSheet);
  
  let registeredCount = 0;

  values.forEach(row => {
    // Indices relative to L (0):
    // 0: Check(L)
    // 1: Proj(M)
    // 2: Task(N)
    // 3: Start(O)
    // 4: Dur(P)
    // 5: Prio(Q)
    // 6: Memo(R)
    // 7: Cal(S)
    // 8: TID(T)
    // 9: Origin(U)
    // 10: EID(V)

    const taskName = row[2];
    const startTime = row[3];
    const duration = row[4];
    const priority = row[5];
    const memo = row[6];
    const calType = row[7]; 
    const taskId = row[8];  
    const sheetName = row[9]; 
    const currentEventId = row[10]; 

    if (!currentEventId && taskName && taskId && sheetName && calType && startTime instanceof Date && !isNaN(startTime)) {
      
      const targetSheet = ss.getSheetByName(sheetName);
      if (!targetSheet) return;

      const startRow = (sheetName === TASK_SHEET_NAME) ? TASK_START_ROW : PROJECT_TASK_START_ROW;
      const targetLastRow = targetSheet.getLastRow();
      if (targetLastRow < startRow) return;

      const idRange = targetSheet.getRange(startRow, COL_TASK_ID, targetLastRow - startRow + 1, 1);
      const idValues = idRange.getValues();
      const targetIndex = idValues.findIndex(r => String(r[0]) === String(taskId));

      if (targetIndex !== -1) {
        const rowNum = startRow + targetIndex;
        
        if (calendarMap[calType]) {
          try {
            const cal = CalendarApp.getCalendarById(calendarMap[calType]);
            if (cal) {
              const start = new Date(startTime);
              const end = new Date(start);
              end.setMinutes(end.getMinutes() + (Number(duration) || 30));
              
              const desc = `${memo || ''}\n\nã‚¿ã‚¹ã‚¯ID: ${taskId}\nã‚·ãƒ¼ãƒˆé€£æº`;
              const event = cal.createEvent(taskName, start, end, {
                description: desc
              });
              event.addPopupReminder(0);
              
              targetSheet.getRange(rowNum, COL_START_TIME).setValue(start);
              targetSheet.getRange(rowNum, COL_DURATION).setValue(Number(duration) || 30);
              if (priority) targetSheet.getRange(rowNum, COL_PRIORITY).setValue(priority);
              if (memo) targetSheet.getRange(rowNum, COL_MEMO).setValue(memo);
              
              targetSheet.getRange(rowNum, COL_CAL_TYPE).setValue(calType);
              targetSheet.getRange(rowNum, COL_EVENT_ID).setValue(event.getId());
              
              registeredCount++;
            }
          } catch (e) {
            console.warn(`Calendar reg failed: ${taskName}`, e);
          }
        }
      }
    }
  });

  if (registeredCount > 0) {
    ss.toast(`${registeredCount}ä»¶ã‚’ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã«ç™»éŒ²ã—ã¾ã—ãŸ`, 'å®Œäº†');
  }
}

/**
 * å·¦å´(ç¢ºå®š)ãƒªã‚¹ãƒˆã®å¤‰æ›´ã‚’å…ƒã‚·ãƒ¼ãƒˆã¨ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã«åæ˜ 
 */
function reflectDashboardChanges() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(RECENT_TASK_SHEET_NAME);
  if (!dashboardSheet) return;

  const lastRow = dashboardSheet.getLastRow();
  if (lastRow < 3) return;

  const range = dashboardSheet.getRange(3, 1, lastRow - 2, 10); // A-J (10åˆ—)ã‚’å–å¾—
  const values = range.getValues();
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  const calendarMap = getCalendarMap(settingsSheet); 

  const changesBySheet = {};

  values.forEach((row, i) => {
    // å¿…é ˆ: TaskID (Index 7 / Håˆ—) ã¨ SheetName (Index 8 / Iåˆ—)
    if (!row[7] || !row[8]) return; 

    const sheetName = row[8];
    if (!changesBySheet[sheetName]) changesBySheet[sheetName] = [];
    
    changesBySheet[sheetName].push({
      dashboardRowIndex: i, 
      taskName: row[2],     // C: TaskName
      startTime: row[3],    // D: StartTime
      duration: row[4],     // E: Duration
      priority: row[5],     // F: Priority
      memo: row[6],         // G: Memo
      taskId: row[7],       // H: TaskID
      eventId: row[9]       // J: EventID
    });
  });

  let updateCount = 0;

  for (const [sheetName, items] of Object.entries(changesBySheet)) {
    const targetSheet = ss.getSheetByName(sheetName);
    if (!targetSheet) continue;

    const targetLastRow = targetSheet.getLastRow();
    const startRow = (sheetName === TASK_SHEET_NAME) ? TASK_START_ROW : PROJECT_TASK_START_ROW;
    
    if (targetLastRow < startRow) continue;

    // ä¿®æ­£: å¿…è¦ãªå…¨åˆ—ã‚’èª­ã¿è¾¼ã‚€ (CalType, EventIDãªã©ãŒå«ã¾ã‚Œã‚‹ã‚ˆã†ã«)
    const targetRange = targetSheet.getRange(startRow, 1, targetLastRow - startRow + 1, TASK_AREA_LAST_COL);
    const targetValues = targetRange.getValues();
    let sheetModified = false;

    items.forEach(item => {
      const targetIndex = targetValues.findIndex(r => String(r[COL_TASK_ID - 1]) === String(item.taskId));

      if (targetIndex !== -1) {
        const targetRowData = targetValues[targetIndex];
        let isChanged = false;
        
        const targetStart = targetRowData[COL_START_TIME - 1];
        let newStart = item.startTime;
        
        if (newStart && !(newStart instanceof Date)) newStart = new Date(newStart);

        if (newStart instanceof Date && !isNaN(newStart)) {
           if (!(targetStart instanceof Date) || Math.abs(targetStart.getTime() - newStart.getTime()) > 1000) {
             isChanged = true;
             targetRowData[COL_START_TIME - 1] = newStart;
           }
        }

        if (Number(targetRowData[COL_DURATION - 1]) != Number(item.duration)) {
          isChanged = true;
          targetRowData[COL_DURATION - 1] = item.duration;
        }

        if (targetRowData[COL_PRIORITY - 1] != item.priority) {
          isChanged = true;
          targetRowData[COL_PRIORITY - 1] = item.priority;
        }

        if (targetRowData[COL_MEMO - 1] != item.memo) {
          isChanged = true;
          targetRowData[COL_MEMO - 1] = item.memo;
        }

        if (isChanged) {
          sheetModified = true;
          updateCount++;

          if (item.eventId && newStart instanceof Date) {
            const calType = targetRowData[COL_CAL_TYPE - 1];
            const calId = calendarMap[calType];
            
            if (calId) {
              try {
                const cal = CalendarApp.getCalendarById(calId);
                const event = cal.getEventById(item.eventId);
                if (event) {
                  const end = new Date(newStart);
                  end.setMinutes(end.getMinutes() + (Number(item.duration) || 30));
                  event.setTime(newStart, end);
                  
                  // ãƒ¡ãƒ¢ã‚’èª¬æ˜æ¬„ã«åŒæœŸ
                  const desc = `${item.memo || ''}\n\nã‚¿ã‚¹ã‚¯ID: ${item.taskId}\nã‚·ãƒ¼ãƒˆé€£æº`;
                  event.setDescription(desc);
                }
              } catch (e) {
                console.warn(`Calendar update failed: ${item.taskName}`, e);
              }
            }
          }
        }
      }
    });

    if (sheetModified) {
       targetRange.setValues(targetValues);
    }
  }

  if (updateCount > 0) {
    ss.toast(`${updateCount}ä»¶ã®å¤‰æ›´ã‚’åæ˜ ã—ã¾ã—ãŸ`, 'å®Œäº†');
  }
}

/**
 * ã€æ–°æ©Ÿèƒ½ã€‘ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‹ã‚‰æ—¥æ™‚æƒ…å ±ã‚’å…¨ã‚·ãƒ¼ãƒˆã¸åæ˜ 
 */
function syncFromCalendarToSheets() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  
  const calendarMap = getCalendarMap(settingsSheet);
  const calendarIds = Object.values(calendarMap);
  if (calendarIds.length === 0) return;

  const startTime = new Date();
  startTime.setDate(startTime.getDate() - 7); 
  startTime.setHours(0, 0, 0, 0);
  
  const endTime = new Date();
  endTime.setMonth(endTime.getMonth() + 2); 

  const eventMap = new Map();

  calendarIds.forEach(calId => {
    try {
      const cal = CalendarApp.getCalendarById(calId);
      if (cal) {
        const events = cal.getEvents(startTime, endTime);
        events.forEach(evt => {
          const evtId = evt.getId();
          const start = evt.getStartTime();
          const end = evt.getEndTime();
          const duration = Math.round((end.getTime() - start.getTime()) / (1000 * 60));
          eventMap.set(evtId, { start: start, duration: duration });
        });
      }
    } catch (e) {
      console.warn(`Calendar access error: ${calId}`, e);
    }
  });

  if (eventMap.size === 0) return;

  let updatedCount = 0;
  
  const targetSheets = [];
  const taskSheet = ss.getSheetByName(TASK_SHEET_NAME);
  if (taskSheet) targetSheets.push({ sheet: taskSheet, startRow: TASK_START_ROW });

  const allSheets = ss.getSheets();
  allSheets.forEach(sheet => {
    const sName = sheet.getName();
    if (!EXCLUDED_SHEETS.includes(sName)) {
      targetSheets.push({ sheet: sheet, startRow: PROJECT_TASK_START_ROW });
    }
  });

  targetSheets.forEach(target => {
    const sheet = target.sheet;
    const startRow = target.startRow;
    const lastRow = sheet.getLastRow();
    
    if (lastRow >= startRow) {
      const numRows = lastRow - startRow + 1;
      const range = sheet.getRange(startRow, 1, numRows, TASK_AREA_LAST_COL);
      const values = range.getValues();
      let sheetUpdated = false;

      for (let i = 0; i < values.length; i++) {
        const rowData = values[i];
        const eventId = rowData[COL_EVENT_ID - 1]; 

        if (eventId && eventMap.has(eventId)) {
          const calData = eventMap.get(eventId);
          const currentStart = rowData[COL_START_TIME - 1];
          const currentDuration = rowData[COL_DURATION - 1];

          let isDiff = false;
          
          if (currentStart instanceof Date) {
            if (Math.abs(currentStart.getTime() - calData.start.getTime()) > 1000) isDiff = true;
          } else {
            isDiff = true; 
          }

          if (Number(currentDuration) !== calData.duration) isDiff = true;

          if (isDiff) {
            values[i][COL_START_TIME - 1] = calData.start;
            values[i][COL_DURATION - 1] = calData.duration;
            updatedCount++;
            sheetUpdated = true;
          }
        }
      }

      if (sheetUpdated) {
        range.setValues(values);
      }
    }
  });

  if (updatedCount > 0) {
    ss.toast(`${updatedCount}ä»¶ã®ã‚¿ã‚¹ã‚¯æ—¥æ™‚ã‚’ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‹ã‚‰æ›´æ–°ã—ã¾ã—ãŸ`, 'å®Œäº†');
  }
}

/**
 * ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ›´æ–°æ©Ÿèƒ½ (ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¤‰æ›´: Aåˆ—ã«ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹è¿½åŠ )
 */
function updateDashboard() {
  if (!checkUserPermission()) return; // æ¨©é™ãƒã‚§ãƒƒã‚¯

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(RECENT_TASK_SHEET_NAME);

  if (!dashboardSheet) {
    ss.toast(`ã‚¨ãƒ©ãƒ¼: ã‚·ãƒ¼ãƒˆ "${RECENT_TASK_SHEET_NAME}" ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`, 'ã‚¨ãƒ©ãƒ¼');
    return;
  }

  ensureSheetColumns(dashboardSheet, 22); // A-V (22åˆ—)

  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  const calendarMap = getCalendarMap(settingsSheet);
  const calendarNames = Object.keys(calendarMap);

  // è¨­å®šã‚·ãƒ¼ãƒˆã‹ã‚‰æ‰€è¦æ™‚é–“ãƒªã‚¹ãƒˆã‚’å–å¾—
  let durationList = ['15', '30', '45', '60', '90', '120', '180'];
  const settingsLastRow = settingsSheet.getLastRow();
  if (settingsLastRow >= 2) {
    const durationVals = settingsSheet.getRange(2, SETTINGS_DURATION_COL, settingsLastRow - 1, 1).getValues();
    const customDurations = durationVals.flat().filter(v => v !== '').map(String);
    if (customDurations.length > 0) {
      durationList = customDurations;
    }
  }

  let targetSheets = [];
  const taskSheet = ss.getSheetByName(TASK_SHEET_NAME);
  if (taskSheet) targetSheets.push({ sheet: taskSheet, startRow: TASK_START_ROW, name: TASK_SHEET_NAME }); 

  const allSheets = ss.getSheets();
  allSheets.forEach(sheet => {
    const sName = sheet.getName();
    if (!EXCLUDED_SHEETS.includes(sName)) {
      targetSheets.push({ sheet: sheet, startRow: PROJECT_TASK_START_ROW, name: sName });
    }
  });

  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  const tomorrow = new Date(today);
  tomorrow.setDate(today.getDate() + 1);
  
  const dayAfterTomorrow = new Date(today);
  dayAfterTomorrow.setDate(today.getDate() + 2);
  
  const threeDaysLater = new Date(today);
  threeDaysLater.setDate(today.getDate() + 3);

  let tasks = [];

  targetSheets.forEach(target => {
    const lastRow = target.sheet.getLastRow();
    if (lastRow >= target.startRow) {
      const numRows = lastRow - target.startRow + 1;
      const data = target.sheet.getRange(target.startRow, 1, numRows, TASK_AREA_LAST_COL).getValues();

      data.forEach(row => {
        const isCompleted = (row[0] === true);
        const taskName = row[COL_TASK_NAME - 1];

        if (!isCompleted && taskName) {
          let startTime = row[COL_START_TIME - 1];
          let hasDate = false;

          if (startTime) {
             if (!(startTime instanceof Date)) {
                const d = new Date(startTime);
                if (!isNaN(d.getTime())) {
                    startTime = d;
                    hasDate = true;
                }
             } else if (!isNaN(startTime.getTime())) {
                 hasDate = true;
             }
          }

          if (hasDate) {
            const d = new Date(startTime);
            d.setHours(0, 0, 0, 0);
            const checkDateVal = d.getTime();

            if (checkDateVal < threeDaysLater.getTime()) {
              tasks.push({
                projectName: (target.name === TASK_SHEET_NAME && row[COL_PROJECT_NAME - 1]) ? row[COL_PROJECT_NAME - 1] : target.name,
                taskName: taskName,
                startTime: startTime,
                checkDate: checkDateVal,
                duration: row[COL_DURATION - 1],
                priority: row[COL_PRIORITY - 1],
                memo: row[COL_MEMO - 1],
                taskId: row[COL_TASK_ID - 1],     
                originSheet: target.name,         
                eventId: row[COL_EVENT_ID - 1],
                calType: row[COL_CAL_TYPE - 1]
              });
            }
          } else {
            tasks.push({
                type: 'unscheduled',
                projectName: (target.name === TASK_SHEET_NAME && row[COL_PROJECT_NAME - 1]) ? row[COL_PROJECT_NAME - 1] : target.name,
                taskName: taskName,
                startTime: '',
                duration: row[COL_DURATION - 1],
                priority: row[COL_PRIORITY - 1],
                memo: row[COL_MEMO - 1],
                calType: row[COL_CAL_TYPE - 1],
                taskId: row[COL_TASK_ID - 1],
                originSheet: target.name,
                eventId: row[COL_EVENT_ID - 1]
            });
          }
        }
      });
    }
  });

  const expiredTasks = [];
  const todayTasks = [];
  const tomorrowTasks = [];
  const dayAfterTasks = [];
  const unscheduledTasks = [];

  tasks.forEach(t => {
    if (t.type === 'unscheduled') {
        unscheduledTasks.push(t);
    } else {
        if (t.checkDate < today.getTime()) expiredTasks.push(t);
        else if (t.checkDate < tomorrow.getTime()) todayTasks.push(t);
        else if (t.checkDate < dayAfterTomorrow.getTime()) tomorrowTasks.push(t);
        else dayAfterTasks.push(t);
    }
  });

  const priorityMap = { 'ç·Šæ€¥': 4, 'é«˜ã„': 3, 'ä¸­': 2, 'ä½ã„': 1 };
  const sortFunc = (a, b) => {
    if (a.checkDate !== b.checkDate) return a.checkDate - b.checkDate;
    if (a.startTime.getTime() !== b.startTime.getTime()) {
        return a.startTime.getTime() - b.startTime.getTime();
    }
    const pA = priorityMap[a.priority] || 0;
    const pB = priorityMap[b.priority] || 0;
    if (pA !== pB) return pB - pA;
    return (Number(a.duration)||0) - (Number(b.duration)||0);
  };

  const unscheduledSortFunc = (a, b) => {
    const pA = priorityMap[a.priority] || 0;
    const pB = priorityMap[b.priority] || 0;
    if (pA !== pB) return pB - pA;
    return (Number(a.duration)||0) - (Number(b.duration)||0);
  };

  expiredTasks.sort(sortFunc);
  todayTasks.sort(sortFunc);
  tomorrowTasks.sort(sortFunc);
  dayAfterTasks.sort(sortFunc);
  unscheduledTasks.sort(unscheduledSortFunc);

  let leftRows = [];
  let pinkRows = [], greenRows = [], boldRows = [];
  const formatDate = (d) => Utilities.formatDate(d, Session.getScriptTimeZone(), 'MM/dd(E)');
  const emptyRow10 = new Array(10).fill(''); 

  if (expiredTasks.length > 0) {
    leftRows.push([false, 'âš  æœŸé™åˆ‡ã‚Œãƒ»æœªå®Œäº†', '', '', '', '', '', '', '', '']); 
    boldRows.push(leftRows.length - 1);
    expiredTasks.forEach(t => {
      // A:Check, B:Proj, C:Task, D:Start, E:Dur, F:Prio, G:Memo, H:TID(Hide), I:Origin(Hide), J:EID(Hide)
      leftRows.push([false, t.projectName, t.taskName, t.startTime, t.duration, t.priority, t.memo, t.taskId, t.originSheet, t.eventId]);
      greenRows.push(leftRows.length - 1);
    });
    leftRows.push(emptyRow10);
  }
  leftRows.push([false, `â–  æœ¬æ—¥ (${formatDate(today)})`, '', '', '', '', '', '', '', '']);
  boldRows.push(leftRows.length - 1);
  if (todayTasks.length === 0) {
    leftRows.push([false, '(äºˆå®šãªã—)', '', '', '', '', '', '', '', '']);
  } else {
    todayTasks.forEach(t => {
      leftRows.push([false, t.projectName, t.taskName, t.startTime, t.duration, t.priority, t.memo, t.taskId, t.originSheet, t.eventId]);
      pinkRows.push(leftRows.length - 1); 
    });
  }
  leftRows.push(emptyRow10);
  leftRows.push([false, `â–  æ˜æ—¥ (${formatDate(tomorrow)})`, '', '', '', '', '', '', '', '']);
  boldRows.push(leftRows.length - 1);
  if (tomorrowTasks.length === 0) leftRows.push([false, '(äºˆå®šãªã—)', '', '', '', '', '', '', '', '']);
  else tomorrowTasks.forEach(t => leftRows.push([false, t.projectName, t.taskName, t.startTime, t.duration, t.priority, t.memo, t.taskId, t.originSheet, t.eventId]));
  leftRows.push(emptyRow10);
  leftRows.push([false, `â–  æ˜å¾Œæ—¥ (${formatDate(dayAfterTomorrow)})`, '', '', '', '', '', '', '', '']);
  boldRows.push(leftRows.length - 1);
  if (dayAfterTasks.length === 0) leftRows.push([false, '(äºˆå®šãªã—)', '', '', '', '', '', '', '', '']);
  else dayAfterTasks.forEach(t => leftRows.push([false, t.projectName, t.taskName, t.startTime, t.duration, t.priority, t.memo, t.taskId, t.originSheet, t.eventId]));

  // å³å´: [Check, Proj, Task, Start, Dur, Prio, MEMO, Cal, TID, Origin, EID] -> 11 cols
  // L=0, M=1, N=2, O=3, P=4, Q=5, R=6, S=7, T=8, U=9, V=10
  let rightRows = [];
  rightRows.push([false, 'ã€æœªè¨­å®šã‚¿ã‚¹ã‚¯ã€‘', '', '', '', '', '', '', '', '', '']);
  unscheduledTasks.forEach(t => {
    rightRows.push([false, t.projectName, t.taskName, t.startTime, t.duration, t.priority, t.memo, t.calType, t.taskId, t.originSheet, t.eventId]);
  });

  const maxLines = Math.max(leftRows.length, rightRows.length);
  const startRow = 3;
  
  // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹å¸¸è¨­åŒ– (A3)
  const a3Val = dashboardSheet.getRange('A3').getDataValidation();
  if (!a3Val) {
      dashboardSheet.getRange(startRow, 1, 1000, 1).insertCheckboxes();
      dashboardSheet.getRange(startRow, 12, 1000, 1).insertCheckboxes(); // Låˆ— (12)
  }

  const currentMax = dashboardSheet.getLastRow();
  const clearHeight = Math.max(currentMax - startRow + 1, maxLines); 
  
  if (clearHeight > 0) {
    // A, Låˆ—ã¯Contentã®ã¿ã‚¯ãƒªã‚¢
    dashboardSheet.getRange(startRow, 1, clearHeight, 1).clearContent(); // A (Check)
    dashboardSheet.getRange(startRow, 12, clearHeight, 1).clearContent(); // L (Check)
    
    // ä»–ã®åˆ—ã¯å…¨ã‚¯ãƒªã‚¢ (Validationå«ã‚€)
    // B-K (2-11) => 10åˆ—
    dashboardSheet.getRange(startRow, 2, clearHeight, 10).clearContent().clearDataValidations().clearFormat();
    // M-V (13-22) => 10åˆ—
    dashboardSheet.getRange(startRow, 13, clearHeight, 10).clearContent().clearDataValidations().clearFormat();
  }

  const finalValues = [];
  const emptyRight = new Array(11).fill('');
  const emptyRightWithCheck = [false, ...new Array(10).fill('')];

  for (let i = 0; i < maxLines; i++) {
    const left = leftRows[i] || emptyRow10;
    const right = rightRows[i] || emptyRightWithCheck; 
    finalValues.push([...left, '', ...right]); // Left(10) + K(1) + Right(11) = 22
  }

  if (finalValues.length > 0) {
    const range = dashboardSheet.getRange(startRow, 1, finalValues.length, 22);
    range.setValues(finalValues);

    // ãƒ˜ãƒƒãƒ€ãƒ¼æ›¸ãæˆ»ã—(ã‚ºãƒ¬å¯¾å¿œ)
    dashboardSheet.getRange('B2').setValue('ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå');
    dashboardSheet.getRange('C2').setValue('ã‚¿ã‚¹ã‚¯å');
    dashboardSheet.getRange('D2').setValue('é–‹å§‹æ—¥æ™‚');
    dashboardSheet.getRange('E2').setValue('æ‰€è¦æ™‚é–“');
    dashboardSheet.getRange('F2').setValue('å„ªå…ˆåº¦');
    dashboardSheet.getRange('G2').setValue('ãƒ¡ãƒ¢'); // New

    dashboardSheet.getRange('M2').setValue('ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå');
    dashboardSheet.getRange('N2').setValue('ã‚¿ã‚¹ã‚¯å');
    dashboardSheet.getRange('O2').setValue('é–‹å§‹æ—¥æ™‚');
    dashboardSheet.getRange('P2').setValue('æ‰€è¦æ™‚é–“');
    dashboardSheet.getRange('Q2').setValue('å„ªå…ˆåº¦');
    dashboardSheet.getRange('R2').setValue('ãƒ¡ãƒ¢');   // New
    dashboardSheet.getRange('S2').setValue('ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼');

    const priorityRule = SpreadsheetApp.newDataValidation().requireValueInList(['ç·Šæ€¥', 'é«˜ã„', 'ä¸­', 'ä½ã„'], true).setAllowInvalid(false).build();
    const durationRule = SpreadsheetApp.newDataValidation().requireValueInList(durationList, true).setAllowInvalid(false).build();
    const dateRule = SpreadsheetApp.newDataValidation().requireDate().setAllowInvalid(true).build();
    
    let calendarRule = null;
    if (calendarNames.length > 0) {
        calendarRule = SpreadsheetApp.newDataValidation().requireValueInList(calendarNames, true).setAllowInvalid(false).build();
    }

    const rangeE = dashboardSheet.getRange(startRow, 5, maxLines, 1); // E: Dur
    const rangeF = dashboardSheet.getRange(startRow, 6, maxLines, 1); // F: Prio
    
    // å³å´
    // L: Check, M: Proj, N: Task, O: Start, P: Dur, Q: Prio, R: Memo, S: Cal
    const rangeP = dashboardSheet.getRange(startRow, 16, maxLines, 1); // P: Dur
    const rangeQ = dashboardSheet.getRange(startRow, 17, maxLines, 1); // Q: Prio
    const rangeS = dashboardSheet.getRange(startRow, 19, maxLines, 1); // S: Cal

    const rangeD = dashboardSheet.getRange(startRow, 4, maxLines, 1); // D: Start
    const rangeO = dashboardSheet.getRange(startRow, 15, maxLines, 1); // O: Start(Right)

    try {
      rangeF.setDataValidation(priorityRule);
      rangeQ.setDataValidation(priorityRule);
      rangeE.setDataValidation(durationRule);
      rangeP.setDataValidation(durationRule);
      rangeD.setDataValidation(dateRule);
      rangeO.setDataValidation(dateRule);
      if (calendarRule) rangeS.setDataValidation(calendarRule);
    } catch(e) {}

    // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®å†ç”Ÿæˆã¨å‰Šé™¤ãƒ«ãƒ¼ãƒ—(removeCheckboxes)ã‚’å»ƒæ­¢ã—é«˜é€ŸåŒ–

    dashboardSheet.clearConditionalFormatRules();

    // èƒŒæ™¯è‰² (Gã¾ã§)
    if (greenRows.length) dashboardSheet.getRangeList(greenRows.map(i => `A${startRow+i}:G${startRow+i}`)).setBackground('#F0F8F0');
    if (pinkRows.length) dashboardSheet.getRangeList(pinkRows.map(i => `A${startRow+i}:G${startRow+i}`)).setBackground('#FFE0E0');
    if (boldRows.length) {
      const ranges = dashboardSheet.getRangeList(boldRows.map(i => `A${startRow+i}:G${startRow+i}`));
      ranges.setFontWeight('bold').setBackground('#EEEEEE');
    }
    // éè¡¨ç¤ºåˆ—ã‚¨ãƒªã‚¢
    // å·¦: H, I, J (8,9,10)
    dashboardSheet.getRange(`H${startRow}:J${startRow}`).setFontWeight('bold'); 
    // å³: T, U, V (20,21,22)
    dashboardSheet.getRange(`T${startRow}:V${startRow}`).setFontWeight('bold'); 

    dashboardSheet.getRange(startRow, 4, maxLines, 1).setNumberFormat('MM/dd HH:mm');
    dashboardSheet.getRange(startRow, 15, maxLines, 1).setNumberFormat('MM/dd HH:mm');

    // åˆ—éš ã— (H=8, I=9, J=10) -> 3åˆ—
    dashboardSheet.hideColumns(8, 3); 
    // å³å´éš ã— (T=20, U=21, V=22) -> 3åˆ—
    dashboardSheet.hideColumns(20, 3);
  }

  ss.toast('ã‚¿ã‚¹ã‚¯ä¸€è¦§ã‚’æ›´æ–°ã—ã¾ã—ãŸ', 'å®Œäº†');
}

// ... executeTasksAction, syncAndSortProjectSheet ...
// ... archiveCompletedTask ...


/**
 * ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã‹ã‚‰ã®é«˜é€Ÿå®Œäº†å‡¦ç†
 */
function completeTaskFromDashboard(sheet, row) {
  // å·¦å´: A(1)ãƒã‚§ãƒƒã‚¯ -> G(7)=TID, H(8)=Origin, I(9)=EID
  // å³å´: K(11)ãƒã‚§ãƒƒã‚¯ -> R(18)=TID, S(19)=Origin, T(20)=EID
  // ã©ã¡ã‚‰ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãŒæŠ¼ã•ã‚ŒãŸã‹åˆ¤å®šã¯é›£ã—ã„ã®ã§ã€ä¸¡æ–¹ãƒã‚§ãƒƒã‚¯ã™ã‚‹(ã‚ã‚‹ã„ã¯getActiveCellã§åˆ¤å®š)
  
  const activeCol = sheet.getActiveCell().getColumn();
  let tidIndex, originIndex;

  if (activeCol === 1) { // å·¦å´ (Aåˆ—)
    tidIndex = 8;  // Håˆ—
    originIndex = 9; // Iåˆ—
  } else if (activeCol === 12) { // å³å´ (Låˆ—)
    tidIndex = 20; // Tåˆ—
    originIndex = 21; // Uåˆ—
  } else {
    return; // Aåˆ—ã§ã‚‚Låˆ—ã§ã‚‚ãªã‘ã‚Œã°ä½•ã‚‚ã—ãªã„
  }

  const rowVals = sheet.getRange(row, 1, 1, 22).getValues()[0];
  const taskId = rowVals[tidIndex - 1];
  const originSheetName = rowVals[originIndex - 1];

  // Header Check: If no Task ID, it's a header or spacer. Uncheck and return.
  if (!taskId) {
    sheet.getRange(row, activeCol).setValue(false);
    return;
  }

  // ç”»é¢ä¸Šã‹ã‚‰å³åº§ã«æ¶ˆã™ (è¡Œå‰Šé™¤ã§ã¯ãªãã‚»ãƒ«å‰Šé™¤ã§ä¸Šã«è©°ã‚ã‚‹)
  try {
    if (activeCol === 1) {
      sheet.getRange(row, 1, 1, 10).deleteCells(SpreadsheetApp.Dimension.ROWS); // A-J (10åˆ—)
    } else {
      sheet.getRange(row, 12, 1, 11).deleteCells(SpreadsheetApp.Dimension.ROWS); // L-V (11åˆ—)
    }
    SpreadsheetApp.getActiveSpreadsheet().toast('ã‚¿ã‚¹ã‚¯ã‚’å®Œäº†ã—ã¾ã—ãŸ', 'å®Œäº†');
  } catch (e) {
    console.error(e);
  }

  // è£å´ã§æœ¬å‡¦ç†
  if (taskId && originSheetName) {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const originSheet = ss.getSheetByName(originSheetName);
    if (originSheet) {
      // IDã§æ¤œç´¢
      const startRow = (originSheetName === TASK_SHEET_NAME) ? TASK_START_ROW : PROJECT_TASK_START_ROW;
      const lastRow = originSheet.getLastRow();
      if (lastRow >= startRow) {
        const ids = originSheet.getRange(startRow, COL_TASK_ID, lastRow - startRow + 1, 1).getValues();
        const targetIndex = ids.findIndex(r => String(r[0]) === String(taskId));
        
        if (targetIndex !== -1) {
          const targetRow = startRow + targetIndex;
          if (originSheetName === TASK_SHEET_NAME) {
            moveTaskToCompletedSheet(originSheet, targetRow);
          } else {
            archiveCompletedTask(originSheet, targetRow);
          }
        }
      }
    }
  }
}

/**
 * ã‚·ãƒ¼ãƒˆä½œæˆã®å®Ÿå‡¦ç† (Templateã‚’ã‚³ãƒ”ãƒ¼)
 */
function createNewSheet(name) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const templateSheet = ss.getSheetByName(TEMPLATE_SHEET_NAME);
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  
  if (!templateSheet) {
    ss.toast(`ã‚¨ãƒ©ãƒ¼: "${TEMPLATE_SHEET_NAME}" ã‚·ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`, 'ã‚¨ãƒ©ãƒ¼', 10);
    return;
  }
  if (ss.getSheetByName(name)) return;

  const originalActiveSheet = ss.getActiveSheet();

  try {
    const newSheet = templateSheet.copyTo(ss);
    newSheet.setName(name);
    newSheet.setTabColor(null); // ã‚¿ãƒ–è‰²ã‚’ãƒªã‚»ãƒƒãƒˆ
    newSheet.activate();
    
    if (settingsSheet) {
      const targetIndex = settingsSheet.getIndex();
      ss.moveActiveSheet(targetIndex);
    }

    const titleCell = newSheet.getRange('A3');
    titleCell.setValue(name);
    titleCell.setFontSize(14);
    titleCell.setFontWeight('bold');

    originalActiveSheet.activate();
    ss.toast(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆ "${name}" ã‚’ä½œæˆã—ã¾ã—ãŸ`, 'å®Œäº†', 5);
  } catch (err) {
    ss.toast(`ä½œæˆã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼', 10);
  }
}

/**
 * è£œåŠ©é–¢æ•°: ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼IDãƒãƒƒãƒ—å–å¾—
 */
function getCalendarMap(sheet) {
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return {};
  const data = sheet.getRange(2, 1, lastRow - 1, 3).getValues();
  const map = {};
  data.forEach(row => {
    const rawName = row[SETTINGS_NAME_COL - 1];
    const name = String(rawName || '').trim();
    let id = row[SETTINGS_ID_COL - 1];
    if (id && id.includes('calendar.google.com')) {
      const match = id.match(/src=([^&]+)/);
      if (match) id = decodeURIComponent(match[1]);
      else {
        const cidMatch = id.match(/cid=([^&]+)/);
        if (cidMatch) id = decodeURIComponent(cidMatch[1]);
      }
    }
    if (name && id) map[name] = id;
  });
  return map;
}

// === ä»¥ä¸‹ã€å¾©æ´»ã—ãŸæ—¢å­˜é–¢æ•°ç¾¤ ===

function moveTaskToCompletedSheet(sourceSheet, row) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const targetSheet = ss.getSheetByName(COMPLETED_SHEET_NAME);
  if (!targetSheet) {
    ss.toast(`ã‚¨ãƒ©ãƒ¼: ã‚·ãƒ¼ãƒˆ "${COMPLETED_SHEET_NAME}" ãŒã‚ã‚Šã¾ã›ã‚“`, 'ã‚¨ãƒ©ãƒ¼');
    sourceSheet.getRange(row, 1).setValue(false);
    return;
  }
  try {
    const targetRow = 2;
    targetSheet.insertRowBefore(targetRow);
    const lastCol = sourceSheet.getLastColumn();
    ensureSheetColumns(targetSheet, lastCol + 1);

    const sourceRange = sourceSheet.getRange(row, 1, 1, lastCol);
    sourceRange.copyTo(targetSheet.getRange(targetRow, 1));
    targetSheet.getRange(targetRow, 1).setValue(true); // ãƒã‚§ãƒƒã‚¯æ¸ˆã¿ã«ã™ã‚‹
    targetSheet.getRange(targetRow, lastCol + 1).setValue(new Date());
    
    sourceSheet.deleteRow(row);
    ss.toast('ã‚¿ã‚¹ã‚¯ã‚’å®Œäº†ã‚·ãƒ¼ãƒˆã¸ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã—ã¾ã—ãŸ', 'å®Œäº†');
  } catch (e) {
    ss.toast(`ç§»å‹•ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'ã‚¨ãƒ©ãƒ¼');
  }
}

function archiveCompletedTask(sheet, row) {
  try {
    const sourceRange = sheet.getRange(row, 1, 1, TASK_AREA_LAST_COL);
    
    // ã€ä¿®æ­£ã€‘ã‚¿ã‚¹ã‚¯åãƒã‚§ãƒƒã‚¯: åå‰ãŒãªã‘ã‚Œã°å‡¦ç†ã›ãšãƒã‚§ãƒƒã‚¯ã‚’å¤–ã™
    const values = sourceRange.getValues()[0];
    const taskName = values[COL_TASK_NAME - 1];
    if (!taskName) {
      sheet.getRange(row, 1).setValue(false);
      return;
    }

    const archiveRangeWidth = TASK_AREA_LAST_COL; 

    // --- ã€è¿½åŠ ã€‘å®Œäº†ã‚¿ã‚¹ã‚¯ã‚·ãƒ¼ãƒˆã¸ã®é›†ç´„è»¢è¨˜ ---
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const completedSheet = ss.getSheetByName(COMPLETED_SHEET_NAME);
    
    if (completedSheet) {
      // 1è¡Œç›®ãŒè¦‹å‡ºã—ã¨ä»®å®šã—ã€2è¡Œç›®ã«æŒ¿å…¥
      const targetRow = 2;
      completedSheet.insertRowBefore(targetRow);
      
      const lastCol = sheet.getLastColumn(); // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã®åˆ—æ•°
      // å®Œäº†ã‚·ãƒ¼ãƒˆã®åˆ—æ•°ãŒè¶³ã‚Šãªã‘ã‚Œã°æ‹¡å¼µ (æœ€ä½ã§ã‚‚ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆåˆ†ã¯ç¢ºä¿)
      ensureSheetColumns(completedSheet, lastCol + 1);

      // ãƒ‡ãƒ¼ã‚¿ã®ã‚³ãƒ”ãƒ¼ (Aåˆ—ã€œLåˆ— + æ—¥æ™‚ãªã©)
      // å€¤ã‚³ãƒ”ãƒ¼ã§è¡Œã†ï¼ˆæ•°å¼ãªã©ãŒå£Šã‚Œãªã„ã‚ˆã†ã«ï¼‰
      const values = sourceRange.getValues()[0];
      
      // ã‚³ãƒ”ãƒ¼å…ˆã¸ã‚»ãƒƒãƒˆ
      // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã®Aåˆ—(0)ã¯ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹(TRUE/FALSE)ãŒå…¥ã£ã¦ã„ã‚‹ã¯ãš
      // å®Œäº†ã‚·ãƒ¼ãƒˆã§ã‚‚ãƒã‚§ãƒƒã‚¯æ¸ˆã¿(TRUE)ã«ã™ã‚‹
      values[0] = true; 

      // å®Œäº†ã‚·ãƒ¼ãƒˆã®å¯¾å¿œåˆ—ã«æ›¸ãè¾¼ã¿
      completedSheet.getRange(targetRow, 1, 1, values.length).setValues([values]);
      
      // å®Œäº†æ—¥æ™‚ã‚’ Xåˆ—(24) ã‚ãŸã‚Šã€ã¾ãŸã¯æœ€çµ‚åˆ—ã«è¿½åŠ 
      // ã“ã“ã§ã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã¨åŒã˜ Xåˆ—(24) ã«åˆã‚ã›ã‚‹ã‹ã€
      // ã‚ã‚‹ã„ã¯ COMPLETED_SHEET_NAME ã®ä»•æ§˜ã«åˆã‚ã›ã‚‹ã€‚
      // moveTaskToCompletedSheet ã§ã¯ `lastCol + 1` ã«æ—¥æ™‚ã‚’å…¥ã‚Œã¦ã„ã‚‹ã€‚
      // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã®åˆ—æ§‹é€ ã¨ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã®åˆ—æ§‹é€ ã¯ã»ã¼åŒã˜(A-L)ãªã®ã§ã€
      // TASK_AREA_LAST_COL(12) ã‚ˆã‚Šã‚‚å¾Œã‚ã«æ—¥æ™‚ã‚’å…¥ã‚Œã‚‹ã€‚
       
      // å®‰å…¨ã®ãŸã‚ã€å®Œäº†ã‚·ãƒ¼ãƒˆã®24åˆ—ç›®(X)ã«æ—¥æ™‚ã‚’å…¥ã‚Œã‚‹ï¼ˆã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã¨çµ±ä¸€ï¼‰
      // ã¾ãŸã¯ moveTaskToCompletedSheet ã¨åˆã‚ã›ã¦ 13åˆ—ç›®(M) ä»¥é™ã«å…¥ã‚Œã‚‹ã€‚
      // ä»Šå›ã¯ã€Œå…¨ã¦ã®åŸºæœ¬çš„ãªæ©Ÿèƒ½ã€ã¨ã—ã¦ archiveCompletedTask ã‚‚ 24åˆ—ç›®ã«å…¥ã‚Œã¦ã„ã‚‹ã®ã§ã€
      // å®Œäº†ã‚·ãƒ¼ãƒˆå´ã§ã‚‚æ—¥æ™‚ã‚’æ˜ç¢ºã«æ®‹ã™ã€‚
      completedSheet.getRange(targetRow, 24).setValue(new Date());
    }
    // ---------------------------------------------

    const insertRange = sheet.getRange(ARCHIVE_START_ROW, ARCHIVE_START_COL, 1, archiveRangeWidth);
    insertRange.insertCells(SpreadsheetApp.Dimension.ROWS);
    
    ensureSheetColumns(sheet, 24); // Xåˆ—(24)ã¾ã§ç¢ºä¿
    sourceRange.copyTo(sheet.getRange(ARCHIVE_START_ROW, ARCHIVE_START_COL));
    sheet.getRange(ARCHIVE_START_ROW, ARCHIVE_START_COL).setValue(true); // ãƒã‚§ãƒƒã‚¯æ¸ˆã¿ã«ã™ã‚‹
    sheet.getRange(ARCHIVE_START_ROW, 24).setValue(new Date()); // Xåˆ—ã«ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
    
    sourceRange.deleteCells(SpreadsheetApp.Dimension.ROWS);
    SpreadsheetApp.getActiveSpreadsheet().toast('å®Œäº†ã‚¿ã‚¹ã‚¯ã‚’ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ï¼†å…¨é›†è¨ˆã‚·ãƒ¼ãƒˆã¸è¨˜éŒ²ã—ã¾ã—ãŸ', 'å®Œäº†');
  } catch (e) {
    SpreadsheetApp.getActiveSpreadsheet().toast(`ç§»å‹•ä¸­ã«ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'ã‚¨ãƒ©ãƒ¼');
  }
}

function createProjectSheets() {
  if (!checkUserPermission()) return; // æ¨©é™ãƒã‚§ãƒƒã‚¯
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const pSheet = ss.getSheetByName(PROJECT_SHEET_NAME);
  if (!pSheet) return;
  const vals = pSheet.getRange(2, 1, pSheet.getLastRow()-1, 1).getValues();
  vals.forEach(r => { 
    if(r[0] && !ss.getSheetByName(String(r[0]).trim())) {
      createNewSheet(String(r[0]).trim());
    }
  });
}

function syncTasksToCalendar() {
  if (!checkUserPermission()) return; // æ¨©é™ãƒã‚§ãƒƒã‚¯
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const taskSheet = ss.getSheetByName(TASK_SHEET_NAME);
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  if (!taskSheet || !settingsSheet) return;
  const calMap = getCalendarMap(settingsSheet);
  const lastRow = taskSheet.getLastRow();
  if (lastRow < TASK_START_ROW) return;

  const range = taskSheet.getRange(TASK_START_ROW, 1, lastRow - TASK_START_ROW + 1, taskSheet.getLastColumn());
  const vals = range.getValues();
  const ids = [];

  for (let i=0; i<vals.length; i++) {
    const row = vals[i];
    const [task, start, dur, type, eid, tid] = [
      row[COL_TASK_NAME-1], row[COL_START_TIME-1], row[COL_DURATION-1],
      row[COL_CAL_TYPE-1], row[COL_EVENT_ID-1], row[COL_TASK_ID-1]
    ];
    if (!eid && task && start && dur && type && tid && calMap[type]) {
      try {
        const cal = CalendarApp.getCalendarById(calMap[type]);
        if (cal) {
          const end = new Date(start);
          end.setMinutes(end.getMinutes() + Number(dur));
          const ev = cal.createEvent(task, start, end, { description: `ã‚¿ã‚¹ã‚¯ID: ${tid}\nProjectsè‡ªå‹•é€£æº` });
          ev.addPopupReminder(0);
          ids.push([ev.getId()]);
        } else { ids.push([eid]); }
      } catch(e) { ids.push([eid]); }
    } else { ids.push([eid]); }
  }
  if (ids.length) taskSheet.getRange(TASK_START_ROW, COL_EVENT_ID, ids.length, 1).setValues(ids);
  ss.toast('Tasksã‚·ãƒ¼ãƒˆåŒæœŸå®Œäº†', 'å®Œäº†');
}

function executeTasksAction() {
  if (!checkUserPermission()) return; // æ¨©é™ãƒã‚§ãƒƒã‚¯
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const taskSheet = ss.getSheetByName(TASK_SHEET_NAME);
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  const calendarMap = getCalendarMap(settingsSheet);

  if (!taskSheet) return;

  const lastRow = taskSheet.getLastRow();
  if (lastRow < TASK_START_ROW) {
    ss.toast('å‡¦ç†å¯¾è±¡ã®ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“', 'å®Œäº†');
    return;
  }

  const MAX_CHECK_ROWS = 60;
  const processRows = Math.min(lastRow - TASK_START_ROW + 1, MAX_CHECK_ROWS);
  const range = taskSheet.getRange(TASK_START_ROW, 1, processRows, TASK_AREA_LAST_COL);
  const values = range.getValues();
  
  let syncCount = 0;
  let idUpdated = false;

  for (let i = 0; i < values.length; i++) {
    const rowData = values[i];
    // ç©ºè¡Œã‚¹ã‚­ãƒƒãƒ—
    if (!rowData.some(c => c !== '')) continue;

    // ã€é‡è¦ã€‘ã‚¿ã‚¹ã‚¯åãŒãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ— (IDç”Ÿæˆã—ãªã„ã€è»¢æ©Ÿã—ãªã„)
    const taskName  = rowData[COL_TASK_NAME - 1];
    if (!taskName) continue;

    const startTime = rowData[COL_START_TIME - 1];
    const duration  = rowData[COL_DURATION - 1];
    const memo      = rowData[COL_MEMO - 1];
    const calType   = rowData[COL_CAL_TYPE - 1];
    const eventId   = rowData[COL_EVENT_ID - 1];
    let taskId    = rowData[COL_TASK_ID - 1];

    if (!taskId) {
        taskId = Utilities.getUuid().split('-')[0];
        values[i][COL_TASK_ID - 1] = taskId;
        idUpdated = true;
    }

    if (!eventId && startTime && taskId) {
      if (calType && calendarMap[calType]) {
        try {
          const calendar = CalendarApp.getCalendarById(calendarMap[calType]);
          if (calendar) {
            const startDate = new Date(startTime);
            const endDate = new Date(startDate);
            const dur = Number(duration) || 30;
            endDate.setMinutes(endDate.getMinutes() + dur);
            
            const desc = `${memo || ''}\n\nã‚¿ã‚¹ã‚¯ID: ${taskId}\nã‚·ãƒ¼ãƒˆé€£æº`;
            const event = calendar.createEvent(taskName, startDate, endDate, {
              description: desc
            });
            event.addPopupReminder(0);
            
            values[i][COL_EVENT_ID - 1] = event.getId();
            syncCount++;
            idUpdated = true;
          }
        } catch (e) { console.error(`Sync Error: ${e.message}`); }
      }
    }
  }

  if (idUpdated) {
    range.setValues(values);
  }

  let moveCount = 0;
  
  for (let i = values.length - 1; i >= 0; i--) {
    const rowData = values[i];
    // ç©ºè¡Œã‚¹ã‚­ãƒƒãƒ—
    if (!rowData.some(c => c !== '')) continue;

    const rawProjectName = rowData[COL_PROJECT_NAME - 1];
    const taskName = rowData[COL_TASK_NAME - 1];
    
    // ã‚¿ã‚¹ã‚¯åãŒãªã‘ã‚Œã°è»¢é€ã‚‚ã—ãªã„
    if (!taskName) continue;

    if (rawProjectName) {
      const projectName = String(rawProjectName).trim();
      
      if (!EXCLUDED_SHEETS.includes(projectName)) {
        const targetSheet = ss.getSheetByName(projectName);
        
        if (targetSheet) {
          try {
            const targetRow = 29;
            // ã€ä¿®æ­£ã€‘è¡Œå…¨ä½“ã§ã¯ãªãã€ã‚¿ã‚¹ã‚¯ã‚¨ãƒªã‚¢(A-L)ã®ã¿ã‚»ãƒ«ã‚’æŒ¿å…¥ã—ã¦ã‚·ãƒ•ãƒˆã™ã‚‹
            // ã“ã‚Œã«ã‚ˆã‚Šå³å´ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åˆ—(Måˆ—ä»¥é™)ã¯ãšã‚Œãªã„
            const insertRange = targetSheet.getRange(targetRow, 1, 1, TASK_AREA_LAST_COL);
            insertRange.insertCells(SpreadsheetApp.Dimension.ROWS);

            // æ›¸å¼ã¨å…¥åŠ›è¦å‰‡ã‚’ã‚³ãƒ”ãƒ¼ (ã‚·ãƒ•ãƒˆã•ã‚ŒãŸç›´ä¸‹ã®è¡Œã‹ã‚‰)
            const sourceFormatRange = targetSheet.getRange(targetRow + 1, 1, 1, TASK_AREA_LAST_COL);
            sourceFormatRange.copyTo(insertRange, SpreadsheetApp.CopyPasteType.PASTE_FORMAT);
            sourceFormatRange.copyTo(insertRange, SpreadsheetApp.CopyPasteType.PASTE_DATA_VALIDATION);

            // ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€
            insertRange.setValues([rowData]);
            
            taskSheet.deleteRow(TASK_START_ROW + i);
            values.splice(i, 1);
            moveCount++;
          } catch (e) { console.error(`Move Error: ${e.message}`); }
        }
      }
    }
  }

  sortAndWriteBack(taskSheet, TASK_START_ROW, values);

  let msg = `å®Œäº†: `;
  if (syncCount > 0) msg += `${syncCount}ä»¶åŒæœŸ, `;
  if (moveCount > 0) msg += `${moveCount}ä»¶è»¢é€, `;
  msg += `ä¸¦ã³æ›¿ãˆã¾ã—ãŸ`;
  ss.toast(msg, 'å®Œäº†');
}

// --- ä¿®æ­£ç‰ˆ: ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ä»˜ãåŒæœŸé–¢æ•° ---
function syncAndSortProjectSheet(sheet) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  const calendarMap = getCalendarMap(settingsSheet);

  console.log(`[Sync] Calendar Map Keys: ${Object.keys(calendarMap).join(', ')}`);

  const lastRow = sheet.getLastRow();
  const numRows = lastRow - PROJECT_TASK_START_ROW + 1;
  if (numRows < 1) return;

  const range = sheet.getRange(PROJECT_TASK_START_ROW, 1, numRows, TASK_AREA_LAST_COL);
  let values = range.getValues();

  let syncCount = 0;
  let updateCount = 0;
  let warningMsg = '';

  for (let i = 0; i < values.length; i++) {
    const rowData = values[i];
    if (!rowData.some(c => c !== '')) continue;

    const taskName = rowData[COL_TASK_NAME - 1];
    let startTime = rowData[COL_START_TIME - 1]; // Let as variable for casting
    const duration = rowData[COL_DURATION - 1];
    const memo = rowData[COL_MEMO - 1];
    const calType = rowData[COL_CAL_TYPE - 1];
    const eventId = rowData[COL_EVENT_ID - 1];
    let taskId = rowData[COL_TASK_ID - 1];

    if (!taskId && taskName) {
      taskId = Utilities.getUuid().split('-')[0];
      rowData[COL_TASK_ID - 1] = taskId;
    }

    if (taskName && startTime) {
      if (!calType) continue;

      const trimmedType = String(calType).trim();
      const calId = calendarMap[trimmedType];
      
      console.log(`[Sync] Row ${i+PROJECT_TASK_START_ROW}: ${taskName} (${trimmedType}) -> ${calId ? 'Found' : 'Not Found'}`);

      if (!calId) {
        if (!warningMsg) warningMsg = `è¨­å®šã«ãªã„ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ç¨®åˆ¥: ${trimmedType}`;
        continue;
      }

      try {
        const cal = CalendarApp.getCalendarById(calId);
        if (cal) {
          // Dateå‹å¤‰æ›ã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
          let startDate = startTime;
          if (typeof startDate === 'string' || !(startDate instanceof Date)) {
             startDate = new Date(startTime);
          }
          if (isNaN(startDate.getTime())) {
            console.warn(`[Sync] Invalid Date for ${taskName}: ${startTime}`);
            continue;
          }

          const endDate = new Date(startDate);
          const d = Number(duration) || 30;
          endDate.setMinutes(endDate.getMinutes() + d);

          // ãƒ¡ãƒ¢æ¬„åŒæœŸç”¨èª¬æ˜æ–‡
          const desc = `${memo || ''}\n\nã‚¿ã‚¹ã‚¯ID: ${taskId}\nã‚·ãƒ¼ãƒˆé€£æº`;

          if (!eventId) {
            // æ–°è¦
            console.log(`[Sync] Creating new event for ${taskName}`);
            const ev = cal.createEvent(taskName, startDate, endDate, { description: desc });
            ev.addPopupReminder(0);
            rowData[COL_EVENT_ID - 1] = ev.getId();
            syncCount++;
          } else {
            // æ›´æ–°ãƒã‚§ãƒƒã‚¯
            try {
               const ev = cal.getEventById(eventId);
               if (ev) {
                 const evStart = ev.getStartTime();
                 const evEnd = ev.getEndTime();
                 const evNote = ev.getDescription() || '';

                 let needUpdate = false;
                 
                 // æ™‚é–“æ¯”è¼ƒ (1åˆ†ä»¥ä¸Šã®ã‚ºãƒ¬)
                 if (Math.abs(evStart.getTime() - startDate.getTime()) > 60000) {
                     console.log(`[Sync] Start time diff: Ev=${evStart} vs Sheet=${startDate}`);
                     needUpdate = true;
                 }
                 if (Math.abs(evEnd.getTime() - endDate.getTime()) > 60000) {
                     console.log(`[Sync] End time diff`);
                     needUpdate = true;
                 }
                 
                 // èª¬æ˜æ–‡æ¯”è¼ƒ
                 // æ”¹è¡Œã‚³ãƒ¼ãƒ‰æ­£è¦åŒ–ãªã©ã‚’å…¥ã‚ŒãŸã»ã†ãŒè‰¯ã„ãŒã€ã¾ãšã¯å˜ç´”æ¯”è¼ƒ
                 if (evNote !== desc) {
                     console.log(`[Sync] Desc diff for ${taskName}`);
                     ev.setDescription(desc);
                     updateCount++;
                 }

                 if (needUpdate) {
                   console.log(`[Sync] Updating time for ${taskName}`);
                   ev.setTime(startDate, endDate);
                   // Descæ›´æ–°ã§ã‚«ã‚¦ãƒ³ãƒˆã—ã¦ã„ãªã‘ã‚Œã°ã‚«ã‚¦ãƒ³ãƒˆ
                   if (evNote === desc) updateCount++;
                 }
               } else {
                 console.warn(`[Sync] Event not found: ${eventId}`);
               }
            } catch(e) {
               console.warn(`[Sync] Event update error: ${eventId}, ${e.message}`);
            }
          }
        }
      } catch (e) { console.error(e); }
    }
  }

  sortAndWriteBack(sheet, PROJECT_TASK_START_ROW, values);

  let msg = [];
  if (syncCount > 0) msg.push(`${syncCount}ä»¶æ–°è¦`);
  if (updateCount > 0) msg.push(`${updateCount}ä»¶æ›´æ–°`);
  if (warningMsg) msg.push(`âš ${warningMsg}`);
  if (msg.length === 0) msg.push('å¤‰æ›´ãªã—');
  msg.push('ä¸¦ã³æ›¿ãˆå®Œäº†');
  
  ss.toast(msg.join(', '), 'å®Œäº†');
}

function sortAndWriteBack(sheet, startRow, values) {
  const withDate = [];
  const withoutDate = [];

  for (let i = 0; i < values.length; i++) {
    const rowData = values[i];
    if (!rowData.some(c => c !== '')) continue;

    const startTime = rowData[COL_START_TIME - 1];
    if (startTime instanceof Date && !isNaN(startTime)) {
      withDate.push(rowData);
    } else {
      withoutDate.push(rowData);
    }
  }

  const priorityMap = { 'ç·Šæ€¥': 4, 'é«˜ã„': 3, 'ä¸­': 2, 'ä½ã„': 1 };
  const getPriorityScore = (p) => priorityMap[p] || 0;

  const sortFunc = (a, b) => {
    const priA = getPriorityScore(a[COL_PRIORITY - 1]);
    const priB = getPriorityScore(b[COL_PRIORITY - 1]);
    const durA = Number(a[COL_DURATION - 1]) || 0;
    const durB = Number(b[COL_DURATION - 1]) || 0;
    if (priA !== priB) return priB - priA; 
    return durA - durB;
  };

  withDate.sort((a, b) => {
    const dateA = a[COL_START_TIME - 1].getTime();
    const dateB = b[COL_START_TIME - 1].getTime();
    if (dateA !== dateB) return dateA - dateB; 
    return sortFunc(a, b);
  });
  withoutDate.sort(sortFunc);

  const emptyRow = new Array(TASK_AREA_LAST_COL).fill('');
  let resultValues = [];
  if (withDate.length > 0) resultValues = resultValues.concat(withDate);
  if (withoutDate.length > 0) resultValues = resultValues.concat(withoutDate);

  const currentLastRow = sheet.getLastRow();
  const rowsToClear = Math.max(currentLastRow - startRow + 1, values.length);
  if (rowsToClear > 0) {
    sheet.getRange(startRow, 1, rowsToClear, TASK_AREA_LAST_COL).clearContent();
  }
  
  if (resultValues.length > 0) {
    sheet.getRange(startRow, 1, resultValues.length, TASK_AREA_LAST_COL).setValues(resultValues);
  }
}

/**
 * ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‹ã‚‰Inboxã¸å–è¾¼ (é‡è¤‡ãƒã‚§ãƒƒã‚¯ä»˜ã)
 */
function importCalendarToInbox(settingsSheet, row) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let inboxSheet = ss.getSheetByName(CALENDAR_INBOX_SHEET_NAME);

  // ã‚·ãƒ¼ãƒˆãŒãªã‘ã‚Œã°ä½œæˆ (ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã‚’ã‚³ãƒ”ãƒ¼æ¨å¥¨ã ãŒã€ç°¡æ˜“ä½œæˆ)
  if (!inboxSheet) {
    const templateSheet = ss.getSheetByName(TASK_SHEET_NAME); // ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚’ãƒ†ãƒ³ãƒ—ãƒ¬ã«
    if (templateSheet) {
      inboxSheet = templateSheet.copyTo(ss).setName(CALENDAR_INBOX_SHEET_NAME);
      // ä¸­èº«ã‚¯ãƒªã‚¢
      const lastRow = inboxSheet.getLastRow();
      if (lastRow >= TASK_START_ROW) {
         inboxSheet.getRange(TASK_START_ROW, 1, lastRow - TASK_START_ROW + 1, inboxSheet.getLastColumn()).clearContent();
      }
      inboxSheet.getRange('A3').setValue(false).insertCheckbox(); // å®Ÿè¡Œãƒœã‚¿ãƒ³ (A3)
      inboxSheet.getRange('B3').setValue('ã‚¿ã‚¹ã‚¯æŒ¯ã‚Šåˆ†ã‘');       // ãƒ©ãƒ™ãƒ« (B3)
      // ä»–ã®ä½™è¨ˆãªãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ç­‰ã¯å‰Šé™¤
      inboxSheet.getRange('A1:B2').clearContent().removeCheckboxes();
    } else {
      inboxSheet = ss.insertSheet(CALENDAR_INBOX_SHEET_NAME);
      // ãƒ˜ãƒƒãƒ€ãƒ¼ç°¡æ˜“ä½œæˆ
      inboxSheet.getRange('A3').insertCheckbox();
      inboxSheet.getRange('B3').setValue('ã‚¿ã‚¹ã‚¯æŒ¯ã‚Šåˆ†ã‘');
      inboxSheet.appendRow(['', '', '', '', '', '', '', '', '', '']); // 1-3è¡Œç›®èª¿æ•´
      inboxSheet.getRange(4, 1, 1, 10).setValues([['', 'ã‚¿ã‚¹ã‚¯å', 'é–‹å§‹æ—¥æ™‚', 'å„ªå…ˆåº¦', 'æ‰€è¦æ™‚é–“', 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå', '', '', 'CalType', 'EventID']]);
    }
  }

  // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼IDå–å¾—
  const calIdInfo = getCalendarInfoFromRow(settingsSheet, row);
  if (!calIdInfo.id) {
    ss.toast('æœ‰åŠ¹ãªã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼IDãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 'ã‚¨ãƒ©ãƒ¼');
    return;
  }
  
  const calName = calIdInfo.name;
  const calId = calIdInfo.id;
  const cal = CalendarApp.getCalendarById(calId);
  if (!cal) {
    ss.toast(`ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–å¾—å¤±æ•—: ${calId}`, 'ã‚¨ãƒ©ãƒ¼');
    return;
  }

  // é‡è¤‡ãƒã‚§ãƒƒã‚¯ç”¨IDãƒªã‚¹ãƒˆåé›†
  const existingEventIds = new Set();
  const allSheets = ss.getSheets();
  const targetSheetNames = [TASK_SHEET_NAME, CALENDAR_INBOX_SHEET_NAME, ...allSheets.map(s => s.getName()).filter(n => !EXCLUDED_SHEETS.includes(n))];
  
  targetSheetNames.forEach(sName => {
     const s = ss.getSheetByName(sName);
     if (!s) return;
     const startR = (sName === TASK_SHEET_NAME || sName === CALENDAR_INBOX_SHEET_NAME) ? TASK_START_ROW : PROJECT_TASK_START_ROW;
     const lastR = s.getLastRow();
     if (lastR >= startR) {
        const ids = s.getRange(startR, COL_EVENT_ID, lastR - startR + 1, 1).getValues().flat();
        ids.forEach(id => { if(id) existingEventIds.add(String(id)); });
     }
  });

  // ã‚¤ãƒ™ãƒ³ãƒˆå–å¾— (å‰å¾Œ1é€±é–“? ãƒ¦ãƒ¼ã‚¶è¦æœ›ã¯"1é€±é–“åˆ†" -> ä»Šæ—¥ã‹ã‚‰1é€±é–“ã¨ã™ã‚‹)
  const startTime = new Date();
  startTime.setHours(0,0,0,0);
  const endTime = new Date();
  endTime.setDate(endTime.getDate() + 7);

  const events = cal.getEvents(startTime, endTime);
  const newTasks = [];

  events.forEach(evt => {
    const eid = evt.getId();
    if (existingEventIds.has(eid)) return; // é‡è¤‡ã‚¹ã‚­ãƒƒãƒ—

    const title = evt.getTitle();
    const start = evt.getStartTime();
    const end = evt.getEndTime();
    const duration = Math.round((end.getTime() - start.getTime()) / (1000 * 60));
    
    // [Check, TaskName, Start, Priority, Duration, ProjectName, ..., CalType, EventID]
    // A=1, B=2, C=3, D=4, E=5, F=6, ..., I=9, J=10
    const rowData = new Array(12).fill('');
    rowData[COL_TASK_NAME - 1] = title;
    rowData[COL_START_TIME - 1] = start;
    rowData[COL_DURATION - 1] = duration;
    rowData[COL_CAL_TYPE - 1] = calName; // è¨­å®šã‚·ãƒ¼ãƒˆã®åå‰
    rowData[COL_EVENT_ID - 1] = eid;
    // TaskIDã¯ã¾ã ä½œã‚‰ãªã„ï¼ˆæŒ¯ã‚Šåˆ†ã‘æ™‚ã«ç”Ÿæˆï¼‰
    
    newTasks.push(rowData);
  });

  if (newTasks.length > 0) {
    const startRow = inboxSheet.getLastRow() + 1;
    // TASK_START_ROWä»¥ä¸Šã§ã‚ã‚‹ã“ã¨ã‚’ä¿è¨¼
    const writeRow = Math.max(startRow, TASK_START_ROW);
    inboxSheet.getRange(writeRow, 1, newTasks.length, newTasks[0].length).setValues(newTasks);
    ss.toast(`${newTasks.length}ä»¶ã®äºˆå®šã‚’å–ã‚Šè¾¼ã¿ã¾ã—ãŸ`, 'å®Œäº†');
  } else {
    ss.toast('æ–°è¦ã®äºˆå®šã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ', 'å®Œäº†');
  }
}

/**
 * Inboxã‚¿ã‚¹ã‚¯ã‚’æŒ¯ã‚Šåˆ†ã‘
 */
function distributeInboxTasks() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const inboxSheet = ss.getSheetByName(CALENDAR_INBOX_SHEET_NAME);
  if (!inboxSheet) return;

  const lastRow = inboxSheet.getLastRow();
  if (lastRow < TASK_START_ROW) {
    ss.toast('æŒ¯ã‚Šåˆ†ã‘å¯¾è±¡ãŒã‚ã‚Šã¾ã›ã‚“', 'å®Œäº†');
    return;
  }

  const range = inboxSheet.getRange(TASK_START_ROW, 1, lastRow - TASK_START_ROW + 1, TASK_AREA_LAST_COL);
  const values = range.getValues();
  const taskInputSheet = ss.getSheetByName(TASK_SHEET_NAME);
  
  let moveToProjectCount = 0;
  let moveToInputCount = 0;
  const rowsToDelete = [];

  // ä¸‹ã‹ã‚‰å‡¦ç†ã—ã¦å‰Šé™¤ã™ã‚‹ãŸã‚
  for (let i = values.length - 1; i >= 0; i--) {
    const rowData = values[i];
    if (!rowData.some(c => c !== '')) continue; // ç©ºè¡Œã‚¹ã‚­ãƒƒãƒ—

    const taskName = rowData[COL_TASK_NAME - 1];
    if (!taskName) continue; // ã‚¿ã‚¹ã‚¯åãªã—ã¯ç„¡è¦–

    // ã‚¿ã‚¹ã‚¯IDç”Ÿæˆ (ã¾ã ãªã‘ã‚Œã°)
    if (!rowData[COL_TASK_ID - 1]) {
       rowData[COL_TASK_ID - 1] = Utilities.getUuid().split('-')[0];
    }

    const rawProjectName = rowData[COL_PROJECT_NAME - 1];
    const projectName = String(rawProjectName || '').trim();
    let moved = false;

    // 1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåãŒã‚ã‚Šã€ã‹ã¤æœ‰åŠ¹ãªã‚·ãƒ¼ãƒˆãŒã‚ã‚‹å ´åˆ -> ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã¸
    if (projectName && !EXCLUDED_SHEETS.includes(projectName)) {
      const targetSheet = ss.getSheetByName(projectName);
      if (targetSheet) {
        try {
          const targetRow = PROJECT_TASK_START_ROW;
          targetSheet.insertRowBefore(targetRow);
          targetSheet.getRange(targetRow, 1, 1, rowData.length).setValues([rowData]);
          moved = true;
          moveToProjectCount++;
        } catch (e) {
          console.warn(`Move to project failed: ${projectName}`, e);
        }
      }
    }

    // 2. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåãŒãªã„ã€ã¾ãŸã¯ã‚·ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ -> ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã¸
    if (!moved && taskInputSheet) {
        try {
          const targetRow = TASK_START_ROW;
          taskInputSheet.insertRowBefore(targetRow);
          taskInputSheet.getRange(targetRow, 1, 1, rowData.length).setValues([rowData]);
          moved = true;
          moveToInputCount++;
        } catch (e) {
          console.warn(`Move to input failed`, e);
        }
    }

    if (moved) {
      // å‰Šé™¤å¯¾è±¡ã¨ã—ã¦ãƒãƒ¼ã‚¯ (Inboxã‹ã‚‰ã¯æ¶ˆã™)
      inboxSheet.deleteRow(TASK_START_ROW + i);
    }
  }

  // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆå´ãƒ»ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆå´ã®ä¸¦ã³æ›¿ãˆã‚’è¡Œã†ã®ãŒç†æƒ³ã ãŒã€
  // ä»¶æ•°ãŒå¤šã„ã¨é‡ããªã‚‹ã®ã§ã€ä»Šå›ã¯ã€Œè»¢é€ã€ã«ç•™ã‚ã‚‹ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå„ã‚·ãƒ¼ãƒˆã§æ›´æ–°ãƒœã‚¿ãƒ³ã‚’æŠ¼ã›ã°ä¸¦ã¶ï¼‰
  // ã‚‚ã—è¦æœ›ãŒã‚ã‚Œã°ã“ã“ã§ sortAndWriteBack ã‚’å„ã‚·ãƒ¼ãƒˆã«å¯¾ã—ã¦å‘¼ã¶ã€‚
  
  ss.toast(`${moveToProjectCount}ä»¶ã‚’ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¸ã€${moveToInputCount}ä»¶ã‚’ã‚¿ã‚¹ã‚¯å…¥åŠ›ã¸ç§»å‹•ã—ã¾ã—ãŸ`, 'å®Œäº†');
}

/**
 * è¨­å®šã‚·ãƒ¼ãƒˆã®æŒ‡å®šè¡Œã‹ã‚‰ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æƒ…å ±ã‚’å–å¾—
 */
function getCalendarInfoFromRow(sheet, row) {
  const name = sheet.getRange(row, SETTINGS_NAME_COL).getValue();
  let id = sheet.getRange(row, SETTINGS_ID_COL).getValue();
  
  if (id && id.includes('calendar.google.com')) {
      const match = id.match(/src=([^&]+)/);
      if (match) id = decodeURIComponent(match[1]);
      else {
        const cidMatch = id.match(/cid=([^&]+)/);
        if (cidMatch) id = decodeURIComponent(cidMatch[1]);
      }
  }
  return { name, id };
}

/**
 * ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ãŸéš›ã«å£Šã‚Œã‚„ã™ã„ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚„ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã‚’ä¿®å¾©ã™ã‚‹
 */
function repairCheckboxes() {
  if (!checkUserPermission()) return; // æ¨©é™ãƒã‚§ãƒƒã‚¯

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();
  
  try {
    // 1. ã‚¿ã‚¹ã‚¯å…¥åŠ› ï¼† ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼
    const entrySheets = [TASK_SHEET_NAME, CALENDAR_INBOX_SHEET_NAME];
    entrySheets.forEach(name => {
      const sheet = ss.getSheetByName(name);
      if (sheet) {
        sheet.getRange('A3').insertCheckboxes();
        const maxRow = sheet.getMaxRows();
        if (maxRow >= 5) {
          sheet.getRange(5, 1, maxRow - 4, 1).insertCheckboxes();
        }
      }
    });

    // 2. ã‚¿ã‚¹ã‚¯ä¸€è¦§ã‚·ãƒ¼ãƒˆ
    const dashboardSheet = ss.getSheetByName(RECENT_TASK_SHEET_NAME);
    if (dashboardSheet) {
      dashboardSheet.getRange(DASHBOARD_INTEGRATED_CHECKBOX_CELL).insertCheckboxes();
    }

    // 3. è¨­å®šã‚·ãƒ¼ãƒˆ
    const settingSheet = ss.getSheetByName(SETTING_SHEET_NAME);
    if (settingSheet) {
      settingSheet.getRange('A2:A3').insertCheckboxes();
    }

    // 4. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ ï¼† å…¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆï¼‰
    const allSheets = ss.getSheets();
    allSheets.forEach(sheet => {
      try {
        const name = sheet.getName();
        // å›ºå®šã‚·ãƒ¼ãƒˆï¼ˆé™¤å¤–ãƒªã‚¹ãƒˆï¼‰ä»¥å¤–ã€ã¾ãŸã¯ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚·ãƒ¼ãƒˆã§ã‚ã‚Œã°é©ç”¨
        if (!EXCLUDED_SHEETS.includes(name) || name === TEMPLATE_SHEET_NAME) {
          
          // æ˜ç¤ºçš„ãªãƒœã‚¿ãƒ³ã‚»ãƒ«ã®å¾©æ—§(A27) -> ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãŒå…¥ã£ã¦ã„ãªã‘ã‚Œã°å…¥ã‚Œã‚‹
          const btnRange = sheet.getRange(PROJECT_SYNC_SORT_CELL);
          if (!btnRange.getDataValidation()) {
             btnRange.insertCheckboxes();
          }

          const maxRow = sheet.getMaxRows();
          if (maxRow >= PROJECT_TASK_START_ROW) {
            // æ—¢å­˜ã®ãƒ‡ãƒ¼ã‚¿å…¥åŠ›è¦å‰‡(ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹)ãŒãªã„ã‚»ãƒ«ã«å¯¾ã—ã¦ã®ã¿é©ç”¨ã™ã‚‹ã¨è»½ã„ãŒã€
            // ä¿®å¾©ç›®çš„ãªã®ã§ä¸€æ‹¬è¨­å®šã™ã‚‹ï¼ˆãŸã ã—é‡ã„ã‚ˆã†ãªã‚‰ç¯„å›²ã‚’çµã‚‹ï¼‰
            // ã“ã“ã§ã¯å®‰å…¨ã«ä¸€æ‹¬è¨­å®š
            sheet.getRange(PROJECT_TASK_START_ROW, 1, maxRow - PROJECT_TASK_START_ROW + 1, 1).insertCheckboxes();
          }
        }
      } catch (innerE) {
        console.warn(`Repair failed for sheet: ${sheet.getName()}`, innerE);
      }
    });

    ss.toast('ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ä¿®å¾©ãŒå®Œäº†ã—ã¾ã—ãŸ', 'å®Œäº†');
  } catch (e) {
    console.error(e);
    ui.alert('ä¿®å¾©ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + e.message);
  }
}

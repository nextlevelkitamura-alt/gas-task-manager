/**
 * ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®ã‚¿ã‚¹ã‚¯ç®¡ç†ï¼†ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆè‡ªå‹•ä½œæˆã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆå®Œå…¨ç‰ˆï¼‰
 * * ã€æ©Ÿèƒ½ä¸€è¦§ã€‘
 * 1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§ã‚·ãƒ¼ãƒˆã®Aåˆ—ã«å…¥åŠ› -> è¨­å®šã‚·ãƒ¼ãƒˆå·¦å´ã«ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¦æ–°ã‚·ãƒ¼ãƒˆä½œæˆ
 * 2. ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆ(5è¡Œç›®~)ãŠã‚ˆã³å„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆ(29è¡Œç›®~)ã®Cåˆ—ã«å…¥åŠ› -> IDè‡ªå‹•ç”Ÿæˆ
 * 3. ã€å¾©æ´»ã€‘ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã®Aåˆ—(å®Œäº†)ã‚’ON -> ã€Œå®Œäº†ã‚¿ã‚¹ã‚¯ã€ã‚·ãƒ¼ãƒˆã¸ç§»å‹•
 * 4. ã€å¾©æ´»ã€‘å„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã®Aåˆ—(å®Œäº†)ã‚’ON -> åŒã‚·ãƒ¼ãƒˆå†…ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚¨ãƒªã‚¢ã¸ç§»å‹•
 * 5. ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã®F3ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ON -> ã€çµ±åˆæ©Ÿèƒ½ã€‘åŒæœŸãƒ»è»¢é€ãƒ»ä¸¦ã³æ›¿ãˆã‚’ä¸€æ‹¬å®Ÿè¡Œ
 * 6. å€‹åˆ¥ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã§E2ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ON -> ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸ ï¼† ä¸¦ã³æ›¿ãˆ
 * 7. ã€Œã‚¿ã‚¹ã‚¯ä¸€è¦§ã€ã‚·ãƒ¼ãƒˆã®D1ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ON -> ã€çµ±åˆæ©Ÿèƒ½ã€‘ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åæ˜ å¾Œã«ç›´è¿‘ã‚¿ã‚¹ã‚¯ã‚’é›†è¨ˆãƒ»æ›´æ–°
 * - æœªè¨­å®šã‚¿ã‚¹ã‚¯ï¼ˆå³å´ï¼‰ã®æ—¥æ™‚å…¥åŠ› -> ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ç™»éŒ²
 * - ç¢ºå®šã‚¿ã‚¹ã‚¯ï¼ˆå·¦å´ï¼‰ã®å¤‰æ›´ -> ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åæ˜ 
 * - ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å´ã®å¤‰æ›´ -> ã‚·ãƒ¼ãƒˆåæ˜ 
 * - æ‰€è¦æ™‚é–“ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã®è¨­å®šã‚·ãƒ¼ãƒˆå‚ç…§
 * * * * * ã€é‡è¦: æœ€åˆã«å¿…ãšå®Ÿè¡Œã—ã¦ãã ã•ã„ã€‘
 * ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ã€ŒğŸ“… ã‚¿ã‚¹ã‚¯é€£æºã€>ã€Œè¨­å®š: è‡ªå‹•åŒ–ãƒˆãƒªã‚¬ãƒ¼ã‚’ã‚»ãƒƒãƒˆã€ã‚’å®Ÿè¡Œã—ã¦æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã—ã¦ãã ã•ã„ã€‚
 */

// --- è¨­å®šå€¤ ---
const PROJECT_SHEET_NAME = 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§';
const TEMPLATE_SHEET_NAME = 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ';
const TASK_SHEET_NAME = 'ã‚¿ã‚¹ã‚¯å…¥åŠ›';
const SETTING_SHEET_NAME = 'è¨­å®š';
const COMPLETED_SHEET_NAME = 'å®Œäº†ã‚¿ã‚¹ã‚¯';
const RECENT_TASK_SHEET_NAME = 'ã‚¿ã‚¹ã‚¯ä¸€è¦§';
const CALENDAR_INBOX_SHEET_NAME = 'ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼';
const GAS_MANAGE_SHEET_NAME = 'gasç®¡ç†';


// ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆè¨­å®š
const TASK_START_ROW = 5;   // ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã®å…¥åŠ›é–‹å§‹è¡Œ
const PROJECT_TASK_START_ROW = 29; // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã®ã‚¿ã‚¹ã‚¯é–‹å§‹è¡Œ
 
const COL_TASK_NAME = 2;    // Båˆ—
const COL_START_TIME = 3;   // Cåˆ—
const COL_PRIORITY = 4;     // Dåˆ—
const COL_DURATION = 5;     // Eåˆ—
const COL_PROJECT_NAME = 6; // Fåˆ—
// const COL_TAG = 7;       // Gåˆ— (ã‚¿ã‚°?)
const COL_MEMO = 8;         // Håˆ— (å®Ÿãƒ‡ãƒ¼ã‚¿ã¯ã“ã“ã«ã‚ã‚‹)
const COL_CAL_TYPE = 9;     // Iåˆ—
const COL_EVENT_ID = 10;    // Jåˆ—
const COL_TASK_ID = 11;     // Kåˆ—
 
// ã‚¨ãƒªã‚¢å®šç¾©
const TASK_AREA_LAST_COL = 12; // Låˆ—ã¾ã§ç¢ºä¿
const ARCHIVE_START_ROW = 29;  // ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–é–‹å§‹è¡Œ
const ARCHIVE_START_COL = 13;  // Måˆ—ã‹ã‚‰ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–
 
// ã‚¹ãƒãƒ›æ“ä½œç”¨ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ä½ç½®
const SYNC_CHECKBOX_CELL = 'E2';        // ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆç”¨ (F2 -> E2)
const EXECUTE_ALL_CHECKBOX_CELL = 'A3'; // ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆç”¨ (E3 -> A3)
const PROJECT_SYNC_SORT_CELL = 'A27';   // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆç”¨ (D2 -> A27)
const DASHBOARD_INTEGRATED_CHECKBOX_CELL = 'D1'; // ã‚¿ã‚¹ã‚¯ä¸€è¦§ã‚·ãƒ¼ãƒˆç”¨ (å¤‰æ›´ãªã—)
const CALENDAR_IMPORT_CHECKBOX_CELL = 'F1';  // ã‚¿ã‚¹ã‚¯ä¸€è¦§ã‚·ãƒ¼ãƒˆç”¨ (å¤‰æ›´ãªã—)

// è¨­å®šã‚·ãƒ¼ãƒˆåˆ—å®šç¾©
const SETTINGS_NAME_COL = 2;
const SETTINGS_ID_COL = 3;
const SETTINGS_DURATION_COL = 5; // Eåˆ—: æ‰€è¦æ™‚é–“ãƒªã‚¹ãƒˆ

const ANALYSIS_SHEET_NAME = 'ã‚¿ã‚¹ã‚¯é›†è¨ˆ';

// å‡¦ç†ã‹ã‚‰é™¤å¤–ã™ã‚‹ã‚·ãƒ¼ãƒˆåãƒªã‚¹ãƒˆ
const EXCLUDED_SHEETS = [
  PROJECT_SHEET_NAME, 
  TEMPLATE_SHEET_NAME, 
  TASK_SHEET_NAME, 
  SETTING_SHEET_NAME, 
  COMPLETED_SHEET_NAME,
  RECENT_TASK_SHEET_NAME,
  RECENT_TASK_SHEET_NAME,
  CALENDAR_INBOX_SHEET_NAME,
  GAS_MANAGE_SHEET_NAME,
  ANALYSIS_SHEET_NAME,
];


/**
 * ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¿½åŠ 
 */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('ğŸ“… ã‚¿ã‚¹ã‚¯é€£æº')
    .addItem('è¨­å®š: è‡ªå‹•åŒ–ãƒˆãƒªã‚¬ãƒ¼ã‚’ã‚»ãƒƒãƒˆ (æ›´æ–°æ™‚ã‚‚å®Ÿè¡Œ)', 'setupTriggers')
    .addSeparator()
    .addItem('æ‰‹å‹•: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆä½œæˆ', 'createProjectSheets')
    .addItem('æ‰‹å‹•: ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸ (ã‚¿ã‚¹ã‚¯å…¥åŠ›)', 'syncTasksToCalendar')
    .addItem('æ‰‹å‹•: ã€çµ±åˆã€‘åŒæœŸãƒ»è»¢é€ãƒ»ä¸¦ã³æ›¿ãˆ (ã‚¿ã‚¹ã‚¯å…¥åŠ›)', 'executeTasksAction')
    .addItem('æ‰‹å‹•: ã‚¿ã‚¹ã‚¯ä¸€è¦§æ›´æ–° (çµ±åˆç‰ˆ)', 'updateDashboardWithCalendarSync')
    .addSeparator()
    .addItem('æ‰‹å‹•: ã‚¿ã‚¹ã‚¯é›†è¨ˆãƒ»åˆ†æ', 'aggregateAndVisualize')
    .addToUi();
}

/**
 * ã€é‡è¦ã€‘ãƒˆãƒªã‚¬ãƒ¼è¨­å®šç”¨é–¢æ•°
 */
/**
 * ã€é‡è¦ã€‘ãƒˆãƒªã‚¬ãƒ¼è¨­å®šç”¨é–¢æ•°
 * ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰å®Ÿè¡Œã™ã‚‹ã¨ã€ä»¥ä¸‹ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã§è‡ªå‹•å®Ÿè¡ŒãŒã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚
 */
function setupTriggers() {
  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(t => ScriptApp.deleteTrigger(t));

  // 1. ç·¨é›†æ™‚ãƒˆãƒªã‚¬ãƒ¼ï¼ˆæ‰‹å‹•æ“ä½œç”¨ï¼‰
  ScriptApp.newTrigger('onEditTrigger')
    .forSpreadsheet(SpreadsheetApp.getActive())
    .onEdit()
    .create();

  // 2. ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸï¼ˆã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ -> ã‚·ãƒ¼ãƒˆï¼‰: 15åˆ†ã”ã¨ï¼ˆ20åˆ†è¨­å®šãŒãªã„ãŸã‚ï¼‰
  ScriptApp.newTrigger('syncFromCalendarToSheets')
    .timeBased()
    .everyMinutes(15)
    .create();

  // 3. ã‚¿ã‚¹ã‚¯ä¸€è¦§æ›´æ–°ï¼ˆãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æœ€æ–°åŒ–ï¼‰: 1æ™‚é–“ã”ã¨
  ScriptApp.newTrigger('updateDashboard')
    .timeBased()
    .everyHours(1)
    .create();

  // 4. ã‚¿ã‚¹ã‚¯è»¢è¨˜ãƒ»æ•´ç†ï¼ˆã‚¿ã‚¹ã‚¯å…¥åŠ› -> ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆï¼‰: æ¯æ—¥ æ·±å¤œ3æ™‚
  ScriptApp.newTrigger('executeTasksAction')
    .timeBased()
    .atHour(3)
    .everyDays(1)
    .create();

  Browser.msgBox('è¨­å®šå®Œäº†ï¼\\nãƒ»ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸ: 15åˆ†ã”ã¨\\nãƒ»ã‚¿ã‚¹ã‚¯ä¸€è¦§æ›´æ–°: 1æ™‚é–“ã”ã¨\\nãƒ»ã‚¿ã‚¹ã‚¯è»¢è¨˜: æ¯æ—¥3æ™‚\\nã«è¨­å®šã—ã¾ã—ãŸã€‚');
}

/**
 * ç·¨é›†æ™‚ã«å‘¼ã°ã‚Œã‚‹çµ±åˆé–¢æ•°
 */
function onEditTrigger(e) {
  if (!e) return;

  const range = e.range;
  const sheet = range.getSheet();
  const sheetName = sheet.getName();
  const row = range.getRow();
  const col = range.getColumn();
  const val = range.getValue();
  const a1 = range.getA1Notation();

  // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®åˆ¤å®šã‚’ç·©ã‚ã‚‹ (TRUE, true, 1 ãªã©ã«å¯¾å¿œ)
  const isChecked = (val === true || val === 'TRUE' || val === 1);

  // --- ã‚¿ã‚¹ã‚¯ä¸€è¦§(ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰)ã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† ---
  if (sheetName === RECENT_TASK_SHEET_NAME) {
    // å®Œäº†ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ (Aåˆ—)
    if (col === 1 && isChecked && row >= 3) {
      completeTaskFromDashboard(sheet, row); // é«˜é€Ÿå®Œäº†å‡¦ç†
      return;
    }

    if (a1 === DASHBOARD_INTEGRATED_CHECKBOX_CELL && isChecked) {
      SpreadsheetApp.getActiveSpreadsheet().toast('åŒæ–¹å‘åŒæœŸã‚’é–‹å§‹ã—ã¾ã™...', 'å‡¦ç†ä¸­');
      try {
        ensureSheetColumns(sheet, 19);  // åˆ—æ•°å¢—åŠ ã«å¯¾å¿œ
        reflectDashboardChanges(); // å¤‰æ›´åæ˜ 
        processUnscheduledTasks(); // æœªè¨­å®šã‚¿ã‚¹ã‚¯ç™»éŒ²
        syncFromCalendarToSheets(); // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åæ˜ 
        updateDashboard(); // å†é›†è¨ˆ
      }
      catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
      finally { range.setValue(false); }
      return;
    }
    if (a1 === CALENDAR_IMPORT_CHECKBOX_CELL && isChecked) {
      SpreadsheetApp.getActiveSpreadsheet().toast('ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®æ—¥æ™‚å¤‰æ›´ã‚’åæ˜ ä¸­...', 'å‡¦ç†ä¸­');
      try { syncFromCalendarToSheets(); }
      catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
      finally { range.setValue(false); }
      return;
    }
  }

  // --- å€‹åˆ¥ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† ---
  if (!EXCLUDED_SHEETS.includes(sheetName)) {
    // åŒæœŸãƒœã‚¿ãƒ³ A27
    if (a1 === 'A27' && isChecked) {
      SpreadsheetApp.getActiveSpreadsheet().toast('ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸã¨ä¸¦ã³æ›¿ãˆã‚’å®Ÿè¡Œä¸­...', 'å‡¦ç†ä¸­');
      try { syncAndSortProjectSheet(sheet); } 
      catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); } 
      finally { range.setValue(false); }
      return;
    }
    // å®Œäº†ãƒã‚§ãƒƒã‚¯ (Aåˆ—) -> ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ç§»å‹•
    if (col === 1 && isChecked && row >= PROJECT_TASK_START_ROW) {
      archiveCompletedTask(sheet, row);
      return;
    }
    // IDè‡ªå‹•ç”Ÿæˆ (Cåˆ—)
    if (col === COL_TASK_NAME && val && row >= PROJECT_TASK_START_ROW) {
      const idCell = sheet.getRange(row, COL_TASK_ID);
      if (!idCell.getValue()) idCell.setValue(Utilities.getUuid().split('-')[0]);
    }
    return;
  }

  // --- ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† ---
  if (sheetName === TASK_SHEET_NAME) {
    // å®Œäº†ãƒã‚§ãƒƒã‚¯ (Aåˆ—) -> å®Œäº†ã‚¿ã‚¹ã‚¯ã‚·ãƒ¼ãƒˆã¸ç§»å‹•
    if (col === 1 && isChecked && row >= TASK_START_ROW) {
      moveTaskToCompletedSheet(sheet, row);
      return;
    }
    // å˜ä½“åŒæœŸ
    if (a1 === SYNC_CHECKBOX_CELL && isChecked) {
      SpreadsheetApp.getActiveSpreadsheet().toast('ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸã‚’é–‹å§‹ã—ã¾ã™...', 'å‡¦ç†ä¸­');
      try { syncTasksToCalendar(); } finally { range.setValue(false); }
      return;
    }
    // A3: ã€çµ±åˆæ©Ÿèƒ½ã€‘åŒæœŸãƒ»è»¢é€ãƒ»ä¸¦ã³æ›¿ãˆ
    if (a1 === 'A3' && isChecked) {
      SpreadsheetApp.getActiveSpreadsheet().toast('å…¨å‡¦ç†ã‚’ä¸€æ‹¬å®Ÿè¡Œä¸­...\n(åŒæœŸãƒ»è»¢é€ãƒ»ä¸¦ã³æ›¿ãˆ)', 'å‡¦ç†ä¸­');
      try { executeTasksAction(); } 
      catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
      finally { range.setValue(false); }
      return;
    }
    // IDç”Ÿæˆ
    if (col === COL_TASK_NAME && val && row >= TASK_START_ROW) {
      const idCell = sheet.getRange(row, COL_TASK_ID);
      if (!idCell.getValue()) idCell.setValue(Utilities.getUuid().split('-')[0]);
    }
  }

  // --- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§ã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† ---
  if (sheetName === PROJECT_SHEET_NAME && col === 1 && row >= 2 && val) {
    const projectName = String(val).trim();
    if (projectName && !SpreadsheetApp.getActiveSpreadsheet().getSheetByName(projectName)) {
      createNewSheet(projectName);
    }
  }

  // --- è¨­å®šã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† (ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼) ---
  if (sheetName === SETTING_SHEET_NAME) {
    // Aåˆ—ãƒã‚§ãƒƒã‚¯ -> ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼å®Ÿè¡Œ (è¡Œã”ã¨ã«åˆ¤å®š)
    if (col === 1 && isChecked && row >= 2) {
      SpreadsheetApp.getActiveSpreadsheet().toast('ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼ã‚’é–‹å§‹ã—ã¾ã™...', 'å‡¦ç†ä¸­');
      try { importCalendarToInbox(sheet, row); }
      catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
      finally { range.setValue(false); }
      return;
    }
  }

  // --- ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼ã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† (æŒ¯ã‚Šåˆ†ã‘å®Ÿè¡Œ) ---
  if (sheetName === CALENDAR_INBOX_SHEET_NAME) {
     // A3: æŒ¯ã‚Šåˆ†ã‘é–‹å§‹ (ãƒ¦ãƒ¼ã‚¶ãƒ¼è¦æœ›ã«ã‚ˆã‚ŠA3ã«å¤‰æ›´)
     if (a1 === 'A3' && isChecked) {
       SpreadsheetApp.getActiveSpreadsheet().toast('ã‚¿ã‚¹ã‚¯ã®æŒ¯ã‚Šåˆ†ã‘ãƒ»è»¢é€ã‚’é–‹å§‹ã—ã¾ã™...', 'å‡¦ç†ä¸­');
       try { distributeInboxTasks(); }
       catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
       finally { range.setValue(false); }
       return;
     }
  }

  // --- ã‚¿ã‚¹ã‚¯é›†è¨ˆã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† ---
  if (sheetName === ANALYSIS_SHEET_NAME) {
    // A2: é›†è¨ˆå®Ÿè¡Œ -> ãƒ¦ãƒ¼ã‚¶ãƒ¼è¦æœ›ã§ A1(ã¾ãŸã¯ãƒœã‚¿ãƒ³)ã¸
    // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¤‰æ›´: A1ã«ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹
    if (a1 === 'A1' && isChecked) {
      SpreadsheetApp.getActiveSpreadsheet().toast('ã‚¿ã‚¹ã‚¯é›†è¨ˆã¨ã‚°ãƒ©ãƒ•ä½œæˆã‚’å®Ÿè¡Œä¸­...', 'å‡¦ç†ä¸­');
      try { aggregateAndVisualize(); }
      catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
      finally { range.setValue(false); }
      return;
    }
  }
}

/**
 * æ‰‹å‹•å®Ÿè¡Œç”¨ãƒ©ãƒƒãƒ‘ãƒ¼é–¢æ•°
 */
function updateDashboardWithCalendarSync() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(RECENT_TASK_SHEET_NAME);
  if (!sheet) return;
  
  sheet.getRange(DASHBOARD_INTEGRATED_CHECKBOX_CELL).setValue(true);
  ss.toast('å…¨ã‚·ãƒ¼ãƒˆã®ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸãƒ»é›†è¨ˆã‚’é–‹å§‹ã—ã¾ã™...', 'å‡¦ç†ä¸­');
  try {
    ensureSheetColumns(sheet, 18);
    reflectDashboardChanges();
    processUnscheduledTasks();
    syncFromCalendarToSheets();
    updateDashboard();
  }
  catch (err) { console.error(err); ss.toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
  finally { sheet.getRange(DASHBOARD_INTEGRATED_CHECKBOX_CELL).setValue(false); }
}

/**
 * ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°: æŒ‡å®šã—ãŸåˆ—æ•°ã«ãªã‚‹ã‚ˆã†ã«ã‚·ãƒ¼ãƒˆã‚’æ‹¡å¼µã™ã‚‹
 */
function ensureSheetColumns(sheet, requiredCols) {
  const currentCols = sheet.getMaxColumns();
  if (currentCols < requiredCols) {
    sheet.insertColumnsAfter(currentCols, requiredCols - currentCols);
  }
}

/**
 * ã€æ–°è¦ã€‘å³å´(æœªå®š)ãƒªã‚¹ãƒˆã§æ—¥æ™‚ãŒå…¥åŠ›ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚’ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ç™»éŒ²ã—ã€å…ƒã‚·ãƒ¼ãƒˆã¸åæ˜ 
 */
function processUnscheduledTasks() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(RECENT_TASK_SHEET_NAME);
  if (!dashboardSheet) return;

  const lastRow = dashboardSheet.getLastRow();
  if (lastRow < 3) return;

  ensureSheetColumns(dashboardSheet, 18);

  // Fetch L(12) ~ V(22) -> 11 columns
  const range = dashboardSheet.getRange(3, 12, lastRow - 2, 11);
  const values = range.getValues();
  
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  const calendarMap = getCalendarMap(settingsSheet);
  
  let registeredCount = 0;

  values.forEach(row => {
    // Indices relative to L (0):
    // 0: Check(L)
    // 1: Proj(M)
    // 2: Task(N)
    // 3: Start(O)
    // 4: Dur(P)
    // 5: Prio(Q)
    // 6: Memo(R)
    // 7: Cal(S)
    // 8: TID(T)
    // 9: Origin(U)
    // 10: EID(V)

    const taskName = row[2];
    const startTime = row[3];
    const duration = row[4];
    const priority = row[5];
    const memo = row[6];
    const calType = row[7]; 
    const taskId = row[8];  
    const sheetName = row[9]; 
    const currentEventId = row[10]; 

    if (!currentEventId && taskName && taskId && sheetName && calType && startTime instanceof Date && !isNaN(startTime)) {
      
      const targetSheet = ss.getSheetByName(sheetName);
      if (!targetSheet) return;

      const startRow = (sheetName === TASK_SHEET_NAME) ? TASK_START_ROW : PROJECT_TASK_START_ROW;
      const targetLastRow = targetSheet.getLastRow();
      if (targetLastRow < startRow) return;

      const idRange = targetSheet.getRange(startRow, COL_TASK_ID, targetLastRow - startRow + 1, 1);
      const idValues = idRange.getValues();
      const targetIndex = idValues.findIndex(r => String(r[0]) === String(taskId));

      if (targetIndex !== -1) {
        const rowNum = startRow + targetIndex;
        
        if (calendarMap[calType]) {
          try {
            const cal = CalendarApp.getCalendarById(calendarMap[calType]);
            if (cal) {
              const start = new Date(startTime);
              const end = new Date(start);
              end.setMinutes(end.getMinutes() + (Number(duration) || 30));
              
              const desc = `${memo || ''}\n\nã‚¿ã‚¹ã‚¯ID: ${taskId}\nã‚·ãƒ¼ãƒˆé€£æº`;
              const event = cal.createEvent(taskName, start, end, {
                description: desc
              });
              event.addPopupReminder(0);
              
              targetSheet.getRange(rowNum, COL_START_TIME).setValue(start);
              targetSheet.getRange(rowNum, COL_DURATION).setValue(Number(duration) || 30);
              if (priority) targetSheet.getRange(rowNum, COL_PRIORITY).setValue(priority);
              if (memo) targetSheet.getRange(rowNum, COL_MEMO).setValue(memo);
              
              targetSheet.getRange(rowNum, COL_CAL_TYPE).setValue(calType);
              targetSheet.getRange(rowNum, COL_EVENT_ID).setValue(event.getId());
              
              registeredCount++;
            }
          } catch (e) {
            console.warn(`Calendar reg failed: ${taskName}`, e);
          }
        }
      }
    }
  });

  if (registeredCount > 0) {
    ss.toast(`${registeredCount}ä»¶ã‚’ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã«ç™»éŒ²ã—ã¾ã—ãŸ`, 'å®Œäº†');
  }
}

/**
 * å·¦å´(ç¢ºå®š)ãƒªã‚¹ãƒˆã®å¤‰æ›´ã‚’å…ƒã‚·ãƒ¼ãƒˆã¨ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã«åæ˜ 
 */
function reflectDashboardChanges() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(RECENT_TASK_SHEET_NAME);
  if (!dashboardSheet) return;

  const lastRow = dashboardSheet.getLastRow();
  if (lastRow < 3) return;

  const range = dashboardSheet.getRange(3, 1, lastRow - 2, 10); // A-J (10åˆ—)ã‚’å–å¾—
  const values = range.getValues();
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  const calendarMap = getCalendarMap(settingsSheet); 

  const changesBySheet = {};

  values.forEach((row, i) => {
    // å¿…é ˆ: TaskID (Index 7 / Håˆ—) ã¨ SheetName (Index 8 / Iåˆ—)
    if (!row[7] || !row[8]) return; 

    const sheetName = row[8];
    if (!changesBySheet[sheetName]) changesBySheet[sheetName] = [];
    
    changesBySheet[sheetName].push({
      dashboardRowIndex: i, 
      taskName: row[2],     // C: TaskName
      startTime: row[3],    // D: StartTime
      duration: row[4],     // E: Duration
      priority: row[5],     // F: Priority
      memo: row[6],         // G: Memo
      taskId: row[7],       // H: TaskID
      eventId: row[9]       // J: EventID
    });
  });

  let updateCount = 0;

  for (const [sheetName, items] of Object.entries(changesBySheet)) {
    const targetSheet = ss.getSheetByName(sheetName);
    if (!targetSheet) continue;

    const targetLastRow = targetSheet.getLastRow();
    const startRow = (sheetName === TASK_SHEET_NAME) ? TASK_START_ROW : PROJECT_TASK_START_ROW;
    
    if (targetLastRow < startRow) continue;

    // ä¿®æ­£: å¿…è¦ãªå…¨åˆ—ã‚’èª­ã¿è¾¼ã‚€ (CalType, EventIDãªã©ãŒå«ã¾ã‚Œã‚‹ã‚ˆã†ã«)
    const targetRange = targetSheet.getRange(startRow, 1, targetLastRow - startRow + 1, TASK_AREA_LAST_COL);
    const targetValues = targetRange.getValues();
    let sheetModified = false;

    items.forEach(item => {
      const targetIndex = targetValues.findIndex(r => String(r[COL_TASK_ID - 1]) === String(item.taskId));

      if (targetIndex !== -1) {
        const targetRowData = targetValues[targetIndex];
        let isChanged = false;
        
        const targetStart = targetRowData[COL_START_TIME - 1];
        let newStart = item.startTime;
        
        if (newStart && !(newStart instanceof Date)) newStart = new Date(newStart);

        if (newStart instanceof Date && !isNaN(newStart)) {
           if (!(targetStart instanceof Date) || Math.abs(targetStart.getTime() - newStart.getTime()) > 1000) {
             isChanged = true;
             targetRowData[COL_START_TIME - 1] = newStart;
           }
        }

        if (Number(targetRowData[COL_DURATION - 1]) != Number(item.duration)) {
          isChanged = true;
          targetRowData[COL_DURATION - 1] = item.duration;
        }

        if (targetRowData[COL_PRIORITY - 1] != item.priority) {
          isChanged = true;
          targetRowData[COL_PRIORITY - 1] = item.priority;
        }

        if (targetRowData[COL_MEMO - 1] != item.memo) {
          isChanged = true;
          targetRowData[COL_MEMO - 1] = item.memo;
        }

        if (isChanged) {
          sheetModified = true;
          updateCount++;

          if (item.eventId && newStart instanceof Date) {
            const calType = targetRowData[COL_CAL_TYPE - 1];
            const calId = calendarMap[calType];
            
            if (calId) {
              try {
                const cal = CalendarApp.getCalendarById(calId);
                const event = cal.getEventById(item.eventId);
                if (event) {
                  const end = new Date(newStart);
                  end.setMinutes(end.getMinutes() + (Number(item.duration) || 30));
                  event.setTime(newStart, end);
                  
                  // ãƒ¡ãƒ¢ã‚’èª¬æ˜æ¬„ã«åŒæœŸ
                  const desc = `${item.memo || ''}\n\nã‚¿ã‚¹ã‚¯ID: ${item.taskId}\nã‚·ãƒ¼ãƒˆé€£æº`;
                  event.setDescription(desc);
                }
              } catch (e) {
                console.warn(`Calendar update failed: ${item.taskName}`, e);
              }
            }
          }
        }
      }
    });

    if (sheetModified) {
       targetRange.setValues(targetValues);
    }
  }

  if (updateCount > 0) {
    ss.toast(`${updateCount}ä»¶ã®å¤‰æ›´ã‚’åæ˜ ã—ã¾ã—ãŸ`, 'å®Œäº†');
  }
}

/**
 * ã€æ–°æ©Ÿèƒ½ã€‘ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‹ã‚‰æ—¥æ™‚æƒ…å ±ã‚’å…¨ã‚·ãƒ¼ãƒˆã¸åæ˜ 
 */
function syncFromCalendarToSheets() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  
  const calendarMap = getCalendarMap(settingsSheet);
  const calendarIds = Object.values(calendarMap);
  if (calendarIds.length === 0) return;

  const startTime = new Date();
  startTime.setDate(startTime.getDate() - 7); 
  startTime.setHours(0, 0, 0, 0);
  
  const endTime = new Date();
  endTime.setMonth(endTime.getMonth() + 2); 

  const eventMap = new Map();

  calendarIds.forEach(calId => {
    try {
      const cal = CalendarApp.getCalendarById(calId);
      if (cal) {
        const events = cal.getEvents(startTime, endTime);
        events.forEach(evt => {
          const evtId = evt.getId();
          const start = evt.getStartTime();
          const end = evt.getEndTime();
          const duration = Math.round((end.getTime() - start.getTime()) / (1000 * 60));
          eventMap.set(evtId, { start: start, duration: duration });
        });
      }
    } catch (e) {
      console.warn(`Calendar access error: ${calId}`, e);
    }
  });

  if (eventMap.size === 0) return;

  let updatedCount = 0;
  
  const targetSheets = [];
  const taskSheet = ss.getSheetByName(TASK_SHEET_NAME);
  if (taskSheet) targetSheets.push({ sheet: taskSheet, startRow: TASK_START_ROW });

  const allSheets = ss.getSheets();
  allSheets.forEach(sheet => {
    const sName = sheet.getName();
    if (!EXCLUDED_SHEETS.includes(sName)) {
      targetSheets.push({ sheet: sheet, startRow: PROJECT_TASK_START_ROW });
    }
  });

  targetSheets.forEach(target => {
    const sheet = target.sheet;
    const startRow = target.startRow;
    const lastRow = sheet.getLastRow();
    
    if (lastRow >= startRow) {
      const numRows = lastRow - startRow + 1;
      const range = sheet.getRange(startRow, 1, numRows, TASK_AREA_LAST_COL);
      const values = range.getValues();
      let sheetUpdated = false;

      for (let i = 0; i < values.length; i++) {
        const rowData = values[i];
        const eventId = rowData[COL_EVENT_ID - 1]; 

        if (eventId && eventMap.has(eventId)) {
          const calData = eventMap.get(eventId);
          const currentStart = rowData[COL_START_TIME - 1];
          const currentDuration = rowData[COL_DURATION - 1];

          let isDiff = false;
          
          if (currentStart instanceof Date) {
            if (Math.abs(currentStart.getTime() - calData.start.getTime()) > 1000) isDiff = true;
          } else {
            isDiff = true; 
          }

          if (Number(currentDuration) !== calData.duration) isDiff = true;

          if (isDiff) {
            values[i][COL_START_TIME - 1] = calData.start;
            values[i][COL_DURATION - 1] = calData.duration;
            updatedCount++;
            sheetUpdated = true;
          }
        }
      }

      if (sheetUpdated) {
        range.setValues(values);
      }
    }
  });

  if (updatedCount > 0) {
    ss.toast(`${updatedCount}ä»¶ã®ã‚¿ã‚¹ã‚¯æ—¥æ™‚ã‚’ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‹ã‚‰æ›´æ–°ã—ã¾ã—ãŸ`, 'å®Œäº†');
  }
}

/**
 * ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ›´æ–°æ©Ÿèƒ½
 */
/**
 * ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ›´æ–°æ©Ÿèƒ½ (ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¤‰æ›´: Aåˆ—ã«ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹è¿½åŠ )
 */
function updateDashboard() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(RECENT_TASK_SHEET_NAME);

  if (!dashboardSheet) {
    ss.toast(`ã‚¨ãƒ©ãƒ¼: ã‚·ãƒ¼ãƒˆ "${RECENT_TASK_SHEET_NAME}" ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`, 'ã‚¨ãƒ©ãƒ¼');
    return;
  }

  ensureSheetColumns(dashboardSheet, 22); // A-V (22åˆ—)

  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  const calendarMap = getCalendarMap(settingsSheet);
  const calendarNames = Object.keys(calendarMap);

  // è¨­å®šã‚·ãƒ¼ãƒˆã‹ã‚‰æ‰€è¦æ™‚é–“ãƒªã‚¹ãƒˆã‚’å–å¾—
  let durationList = ['15', '30', '45', '60', '90', '120', '180'];
  const settingsLastRow = settingsSheet.getLastRow();
  if (settingsLastRow >= 2) {
    const durationVals = settingsSheet.getRange(2, SETTINGS_DURATION_COL, settingsLastRow - 1, 1).getValues();
    const customDurations = durationVals.flat().filter(v => v !== '').map(String);
    if (customDurations.length > 0) {
      durationList = customDurations;
    }
  }

  let targetSheets = [];
  const taskSheet = ss.getSheetByName(TASK_SHEET_NAME);
  if (taskSheet) targetSheets.push({ sheet: taskSheet, startRow: TASK_START_ROW, name: TASK_SHEET_NAME }); 

  const allSheets = ss.getSheets();
  allSheets.forEach(sheet => {
    const sName = sheet.getName();
    if (!EXCLUDED_SHEETS.includes(sName)) {
      targetSheets.push({ sheet: sheet, startRow: PROJECT_TASK_START_ROW, name: sName });
    }
  });

  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  const tomorrow = new Date(today);
  tomorrow.setDate(today.getDate() + 1);
  
  const dayAfterTomorrow = new Date(today);
  dayAfterTomorrow.setDate(today.getDate() + 2);
  
  const threeDaysLater = new Date(today);
  threeDaysLater.setDate(today.getDate() + 3);

  let tasks = [];

  targetSheets.forEach(target => {
    const lastRow = target.sheet.getLastRow();
    if (lastRow >= target.startRow) {
      const numRows = lastRow - target.startRow + 1;
      const data = target.sheet.getRange(target.startRow, 1, numRows, TASK_AREA_LAST_COL).getValues();

      data.forEach(row => {
        const isCompleted = (row[0] === true);
        const taskName = row[COL_TASK_NAME - 1];

        if (!isCompleted && taskName) {
          let startTime = row[COL_START_TIME - 1];
          let hasDate = false;

          if (startTime) {
             if (!(startTime instanceof Date)) {
                const d = new Date(startTime);
                if (!isNaN(d.getTime())) {
                    startTime = d;
                    hasDate = true;
                }
             } else if (!isNaN(startTime.getTime())) {
                 hasDate = true;
             }
          }

          if (hasDate) {
            const d = new Date(startTime);
            d.setHours(0, 0, 0, 0);
            const checkDateVal = d.getTime();

            if (checkDateVal < threeDaysLater.getTime()) {
              tasks.push({
                projectName: (target.name === TASK_SHEET_NAME && row[COL_PROJECT_NAME - 1]) ? row[COL_PROJECT_NAME - 1] : target.name,
                taskName: taskName,
                startTime: startTime,
                checkDate: checkDateVal,
                duration: row[COL_DURATION - 1],
                priority: row[COL_PRIORITY - 1],
                memo: row[COL_MEMO - 1],
                taskId: row[COL_TASK_ID - 1],     
                originSheet: target.name,         
                eventId: row[COL_EVENT_ID - 1],
                calType: row[COL_CAL_TYPE - 1]
              });
            }
          } else {
            tasks.push({
                type: 'unscheduled',
                projectName: (target.name === TASK_SHEET_NAME && row[COL_PROJECT_NAME - 1]) ? row[COL_PROJECT_NAME - 1] : target.name,
                taskName: taskName,
                startTime: '',
                duration: row[COL_DURATION - 1],
                priority: row[COL_PRIORITY - 1],
                memo: row[COL_MEMO - 1],
                calType: row[COL_CAL_TYPE - 1],
                taskId: row[COL_TASK_ID - 1],
                originSheet: target.name,
                eventId: row[COL_EVENT_ID - 1]
            });
          }
        }
      });
    }
  });

  const expiredTasks = [];
  const todayTasks = [];
  const tomorrowTasks = [];
  const dayAfterTasks = [];
  const unscheduledTasks = [];

  tasks.forEach(t => {
    if (t.type === 'unscheduled') {
        unscheduledTasks.push(t);
    } else {
        if (t.checkDate < today.getTime()) expiredTasks.push(t);
        else if (t.checkDate < tomorrow.getTime()) todayTasks.push(t);
        else if (t.checkDate < dayAfterTomorrow.getTime()) tomorrowTasks.push(t);
        else dayAfterTasks.push(t);
    }
  });

  const priorityMap = { 'ç·Šæ€¥': 4, 'é«˜ã„': 3, 'ä¸­': 2, 'ä½ã„': 1 };
  const sortFunc = (a, b) => {
    if (a.checkDate !== b.checkDate) return a.checkDate - b.checkDate;
    if (a.startTime.getTime() !== b.startTime.getTime()) {
        return a.startTime.getTime() - b.startTime.getTime();
    }
    const pA = priorityMap[a.priority] || 0;
    const pB = priorityMap[b.priority] || 0;
    if (pA !== pB) return pB - pA;
    return (Number(a.duration)||0) - (Number(b.duration)||0);
  };

  const unscheduledSortFunc = (a, b) => {
    const pA = priorityMap[a.priority] || 0;
    const pB = priorityMap[b.priority] || 0;
    if (pA !== pB) return pB - pA;
    return (Number(a.duration)||0) - (Number(b.duration)||0);
  };

  expiredTasks.sort(sortFunc);
  todayTasks.sort(sortFunc);
  tomorrowTasks.sort(sortFunc);
  dayAfterTasks.sort(sortFunc);
  unscheduledTasks.sort(unscheduledSortFunc);

  let leftRows = [];
  let pinkRows = [], greenRows = [], boldRows = [];
  const formatDate = (d) => Utilities.formatDate(d, Session.getScriptTimeZone(), 'MM/dd(E)');
  const emptyRow10 = new Array(10).fill(''); 

  if (expiredTasks.length > 0) {
    leftRows.push([false, 'âš  æœŸé™åˆ‡ã‚Œãƒ»æœªå®Œäº†', '', '', '', '', '', '', '', '']); 
    boldRows.push(leftRows.length - 1);
    expiredTasks.forEach(t => {
      // A:Check, B:Proj, C:Task, D:Start, E:Dur, F:Prio, G:Memo, H:TID(Hide), I:Origin(Hide), J:EID(Hide)
      leftRows.push([false, t.projectName, t.taskName, t.startTime, t.duration, t.priority, t.memo, t.taskId, t.originSheet, t.eventId]);
      greenRows.push(leftRows.length - 1);
    });
    leftRows.push(emptyRow10);
  }
  leftRows.push([false, `â–  æœ¬æ—¥ (${formatDate(today)})`, '', '', '', '', '', '', '', '']);
  boldRows.push(leftRows.length - 1);
  if (todayTasks.length === 0) {
    leftRows.push([false, '(äºˆå®šãªã—)', '', '', '', '', '', '', '', '']);
  } else {
    todayTasks.forEach(t => {
      leftRows.push([false, t.projectName, t.taskName, t.startTime, t.duration, t.priority, t.memo, t.taskId, t.originSheet, t.eventId]);
      pinkRows.push(leftRows.length - 1); 
    });
  }
  leftRows.push(emptyRow10);
  leftRows.push([false, `â–  æ˜æ—¥ (${formatDate(tomorrow)})`, '', '', '', '', '', '', '', '']);
  boldRows.push(leftRows.length - 1);
  if (tomorrowTasks.length === 0) leftRows.push([false, '(äºˆå®šãªã—)', '', '', '', '', '', '', '', '']);
  else tomorrowTasks.forEach(t => leftRows.push([false, t.projectName, t.taskName, t.startTime, t.duration, t.priority, t.memo, t.taskId, t.originSheet, t.eventId]));
  leftRows.push(emptyRow10);
  leftRows.push([false, `â–  æ˜å¾Œæ—¥ (${formatDate(dayAfterTomorrow)})`, '', '', '', '', '', '', '', '']);
  boldRows.push(leftRows.length - 1);
  if (dayAfterTasks.length === 0) leftRows.push([false, '(äºˆå®šãªã—)', '', '', '', '', '', '', '', '']);
  else dayAfterTasks.forEach(t => leftRows.push([false, t.projectName, t.taskName, t.startTime, t.duration, t.priority, t.memo, t.taskId, t.originSheet, t.eventId]));

  // å³å´: [Check, Proj, Task, Start, Dur, Prio, MEMO, Cal, TID, Origin, EID] -> 11 cols
  // L=0, M=1, N=2, O=3, P=4, Q=5, R=6, S=7, T=8, U=9, V=10
  let rightRows = [];
  rightRows.push([false, 'ã€æœªè¨­å®šã‚¿ã‚¹ã‚¯ã€‘', '', '', '', '', '', '', '', '', '']);
  unscheduledTasks.forEach(t => {
    rightRows.push([false, t.projectName, t.taskName, t.startTime, t.duration, t.priority, t.memo, t.calType, t.taskId, t.originSheet, t.eventId]);
  });

  const maxLines = Math.max(leftRows.length, rightRows.length);
  const startRow = 3;
  
  // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹å¸¸è¨­åŒ– (A3)
  const a3Val = dashboardSheet.getRange('A3').getDataValidation();
  if (!a3Val) {
      dashboardSheet.getRange(startRow, 1, 1000, 1).insertCheckboxes();
      dashboardSheet.getRange(startRow, 12, 1000, 1).insertCheckboxes(); // Låˆ— (12)
  }

  const currentMax = dashboardSheet.getLastRow();
  const clearHeight = Math.max(currentMax - startRow + 1, maxLines); 
  
  if (clearHeight > 0) {
    // A, Låˆ—ã¯Contentã®ã¿ã‚¯ãƒªã‚¢
    dashboardSheet.getRange(startRow, 1, clearHeight, 1).clearContent(); // A (Check)
    dashboardSheet.getRange(startRow, 12, clearHeight, 1).clearContent(); // L (Check)
    
    // ä»–ã®åˆ—ã¯å…¨ã‚¯ãƒªã‚¢ (Validationå«ã‚€)
    // B-K (2-11) => 10åˆ—
    dashboardSheet.getRange(startRow, 2, clearHeight, 10).clearContent().clearDataValidations().clearFormat();
    // M-V (13-22) => 10åˆ—
    dashboardSheet.getRange(startRow, 13, clearHeight, 10).clearContent().clearDataValidations().clearFormat();
  }

  const finalValues = [];
  const emptyRight = new Array(11).fill('');
  const emptyRightWithCheck = [false, ...new Array(10).fill('')];

  for (let i = 0; i < maxLines; i++) {
    const left = leftRows[i] || emptyRow10;
    const right = rightRows[i] || emptyRightWithCheck; 
    finalValues.push([...left, '', ...right]); // Left(10) + K(1) + Right(11) = 22
  }

  if (finalValues.length > 0) {
    const range = dashboardSheet.getRange(startRow, 1, finalValues.length, 22);
    range.setValues(finalValues);

    // ãƒ˜ãƒƒãƒ€ãƒ¼æ›¸ãæˆ»ã—(ã‚ºãƒ¬å¯¾å¿œ)
    dashboardSheet.getRange('B2').setValue('ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå');
    dashboardSheet.getRange('C2').setValue('ã‚¿ã‚¹ã‚¯å');
    dashboardSheet.getRange('D2').setValue('é–‹å§‹æ—¥æ™‚');
    dashboardSheet.getRange('E2').setValue('æ‰€è¦æ™‚é–“');
    dashboardSheet.getRange('F2').setValue('å„ªå…ˆåº¦');
    dashboardSheet.getRange('G2').setValue('ãƒ¡ãƒ¢'); // New

    dashboardSheet.getRange('M2').setValue('ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå');
    dashboardSheet.getRange('N2').setValue('ã‚¿ã‚¹ã‚¯å');
    dashboardSheet.getRange('O2').setValue('é–‹å§‹æ—¥æ™‚');
    dashboardSheet.getRange('P2').setValue('æ‰€è¦æ™‚é–“');
    dashboardSheet.getRange('Q2').setValue('å„ªå…ˆåº¦');
    dashboardSheet.getRange('R2').setValue('ãƒ¡ãƒ¢');   // New
    dashboardSheet.getRange('S2').setValue('ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼');

    const priorityRule = SpreadsheetApp.newDataValidation().requireValueInList(['ç·Šæ€¥', 'é«˜ã„', 'ä¸­', 'ä½ã„'], true).setAllowInvalid(false).build();
    const durationRule = SpreadsheetApp.newDataValidation().requireValueInList(durationList, true).setAllowInvalid(false).build();
    const dateRule = SpreadsheetApp.newDataValidation().requireDate().setAllowInvalid(true).build();
    
    let calendarRule = null;
    if (calendarNames.length > 0) {
        calendarRule = SpreadsheetApp.newDataValidation().requireValueInList(calendarNames, true).setAllowInvalid(false).build();
    }

    const rangeE = dashboardSheet.getRange(startRow, 5, maxLines, 1); // E: Dur
    const rangeF = dashboardSheet.getRange(startRow, 6, maxLines, 1); // F: Prio
    
    // å³å´
    // L: Check, M: Proj, N: Task, O: Start, P: Dur, Q: Prio, R: Memo, S: Cal
    const rangeP = dashboardSheet.getRange(startRow, 16, maxLines, 1); // P: Dur
    const rangeQ = dashboardSheet.getRange(startRow, 17, maxLines, 1); // Q: Prio
    const rangeS = dashboardSheet.getRange(startRow, 19, maxLines, 1); // S: Cal

    const rangeD = dashboardSheet.getRange(startRow, 4, maxLines, 1); // D: Start
    const rangeO = dashboardSheet.getRange(startRow, 15, maxLines, 1); // O: Start(Right)

    try {
      rangeF.setDataValidation(priorityRule);
      rangeQ.setDataValidation(priorityRule);
      rangeE.setDataValidation(durationRule);
      rangeP.setDataValidation(durationRule);
      rangeD.setDataValidation(dateRule);
      rangeO.setDataValidation(dateRule);
      if (calendarRule) rangeS.setDataValidation(calendarRule);
    } catch(e) {}

    // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®å†ç”Ÿæˆã¨å‰Šé™¤ãƒ«ãƒ¼ãƒ—(removeCheckboxes)ã‚’å»ƒæ­¢ã—é«˜é€ŸåŒ–

    dashboardSheet.clearConditionalFormatRules();

    // èƒŒæ™¯è‰² (Gã¾ã§)
    if (greenRows.length) dashboardSheet.getRangeList(greenRows.map(i => `A${startRow+i}:G${startRow+i}`)).setBackground('#F0F8F0');
    if (pinkRows.length) dashboardSheet.getRangeList(pinkRows.map(i => `A${startRow+i}:G${startRow+i}`)).setBackground('#FFE0E0');
    if (boldRows.length) {
      const ranges = dashboardSheet.getRangeList(boldRows.map(i => `A${startRow+i}:G${startRow+i}`));
      ranges.setFontWeight('bold').setBackground('#EEEEEE');
    }
    // éè¡¨ç¤ºåˆ—ã‚¨ãƒªã‚¢
    // å·¦: H, I, J (8,9,10)
    dashboardSheet.getRange(`H${startRow}:J${startRow}`).setFontWeight('bold'); 
    // å³: T, U, V (20,21,22)
    dashboardSheet.getRange(`T${startRow}:V${startRow}`).setFontWeight('bold'); 

    dashboardSheet.getRange(startRow, 4, maxLines, 1).setNumberFormat('MM/dd HH:mm');
    dashboardSheet.getRange(startRow, 15, maxLines, 1).setNumberFormat('MM/dd HH:mm');

    // åˆ—éš ã— (H=8, I=9, J=10) -> 3åˆ—
    dashboardSheet.hideColumns(8, 3); 
    // å³å´éš ã— (T=20, U=21, V=22) -> 3åˆ—
    dashboardSheet.hideColumns(20, 3);
  }

  ss.toast('ã‚¿ã‚¹ã‚¯ä¸€è¦§ã‚’æ›´æ–°ã—ã¾ã—ãŸ', 'å®Œäº†');
}

/**
 * ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã‹ã‚‰ã®é«˜é€Ÿå®Œäº†å‡¦ç†
 */
function completeTaskFromDashboard(sheet, row) {
  // å·¦å´: A(1)ãƒã‚§ãƒƒã‚¯ -> G(7)=TID, H(8)=Origin, I(9)=EID
  // å³å´: K(11)ãƒã‚§ãƒƒã‚¯ -> R(18)=TID, S(19)=Origin, T(20)=EID
  // ã©ã¡ã‚‰ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãŒæŠ¼ã•ã‚ŒãŸã‹åˆ¤å®šã¯é›£ã—ã„ã®ã§ã€ä¸¡æ–¹ãƒã‚§ãƒƒã‚¯ã™ã‚‹(ã‚ã‚‹ã„ã¯getActiveCellã§åˆ¤å®š)
  
  const activeCol = sheet.getActiveCell().getColumn();
  let tidIndex, originIndex;

  if (activeCol === 1) { // å·¦å´ (Aåˆ—)
    tidIndex = 8;  // Håˆ—
    originIndex = 9; // Iåˆ—
  } else if (activeCol === 12) { // å³å´ (Låˆ—)
    tidIndex = 20; // Tåˆ—
    originIndex = 21; // Uåˆ—
  } else {
    return; // Aåˆ—ã§ã‚‚Låˆ—ã§ã‚‚ãªã‘ã‚Œã°ä½•ã‚‚ã—ãªã„
  }

  const rowVals = sheet.getRange(row, 1, 1, 22).getValues()[0];
  const taskId = rowVals[tidIndex - 1];
  const originSheetName = rowVals[originIndex - 1];

  // Header Check: If no Task ID, it's a header or spacer. Uncheck and return.
  if (!taskId) {
    sheet.getRange(row, activeCol).setValue(false);
    return;
  }

  // ç”»é¢ä¸Šã‹ã‚‰å³åº§ã«æ¶ˆã™ (è¡Œå‰Šé™¤ã§ã¯ãªãã‚»ãƒ«å‰Šé™¤ã§ä¸Šã«è©°ã‚ã‚‹)
  try {
    if (activeCol === 1) {
      sheet.getRange(row, 1, 1, 10).deleteCells(SpreadsheetApp.Dimension.ROWS); // A-J (10åˆ—)
    } else {
      sheet.getRange(row, 12, 1, 11).deleteCells(SpreadsheetApp.Dimension.ROWS); // L-V (11åˆ—)
    }
    SpreadsheetApp.getActiveSpreadsheet().toast('ã‚¿ã‚¹ã‚¯ã‚’å®Œäº†ã—ã¾ã—ãŸ', 'å®Œäº†');
  } catch (e) {
    console.error(e);
  }

  // è£å´ã§æœ¬å‡¦ç†
  if (taskId && originSheetName) {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const originSheet = ss.getSheetByName(originSheetName);
    if (originSheet) {
      // IDã§æ¤œç´¢
      const startRow = (originSheetName === TASK_SHEET_NAME) ? TASK_START_ROW : PROJECT_TASK_START_ROW;
      const lastRow = originSheet.getLastRow();
      if (lastRow >= startRow) {
        const ids = originSheet.getRange(startRow, COL_TASK_ID, lastRow - startRow + 1, 1).getValues();
        const targetIndex = ids.findIndex(r => String(r[0]) === String(taskId));
        
        if (targetIndex !== -1) {
          const targetRow = startRow + targetIndex;
          if (originSheetName === TASK_SHEET_NAME) {
            moveTaskToCompletedSheet(originSheet, targetRow);
          } else {
            archiveCompletedTask(originSheet, targetRow);
          }
        }
      }
    }
  }
}

/**
 * ã‚·ãƒ¼ãƒˆä½œæˆã®å®Ÿå‡¦ç† (Templateã‚’ã‚³ãƒ”ãƒ¼)
 */
function createNewSheet(name) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const templateSheet = ss.getSheetByName(TEMPLATE_SHEET_NAME);
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  
  if (!templateSheet) {
    ss.toast(`ã‚¨ãƒ©ãƒ¼: "${TEMPLATE_SHEET_NAME}" ã‚·ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`, 'ã‚¨ãƒ©ãƒ¼', 10);
    return;
  }
  if (ss.getSheetByName(name)) return;

  const originalActiveSheet = ss.getActiveSheet();

  try {
    const newSheet = templateSheet.copyTo(ss);
    newSheet.setName(name);
    newSheet.setTabColor(null); // ã‚¿ãƒ–è‰²ã‚’ãƒªã‚»ãƒƒãƒˆ
    newSheet.activate();
    
    if (settingsSheet) {
      const targetIndex = settingsSheet.getIndex();
      ss.moveActiveSheet(targetIndex);
    }

    const titleCell = newSheet.getRange('A3');
    titleCell.setValue(name);
    titleCell.setFontSize(14);
    titleCell.setFontWeight('bold');

    originalActiveSheet.activate();
    ss.toast(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆ "${name}" ã‚’ä½œæˆã—ã¾ã—ãŸ`, 'å®Œäº†', 5);
  } catch (err) {
    ss.toast(`ä½œæˆã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼', 10);
  }
}

/**
 * è£œåŠ©é–¢æ•°: ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼IDãƒãƒƒãƒ—å–å¾—
 */
function getCalendarMap(sheet) {
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return {};
  const data = sheet.getRange(2, 1, lastRow - 1, 3).getValues();
  const map = {};
  data.forEach(row => {
    const name = row[SETTINGS_NAME_COL - 1];
    let id = row[SETTINGS_ID_COL - 1];
    if (id && id.includes('calendar.google.com')) {
      const match = id.match(/src=([^&]+)/);
      if (match) id = decodeURIComponent(match[1]);
      else {
        const cidMatch = id.match(/cid=([^&]+)/);
        if (cidMatch) id = decodeURIComponent(cidMatch[1]);
      }
    }
    if (name && id) map[name] = id;
  });
  return map;
}

// === ä»¥ä¸‹ã€å¾©æ´»ã—ãŸæ—¢å­˜é–¢æ•°ç¾¤ ===

function moveTaskToCompletedSheet(sourceSheet, row) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const targetSheet = ss.getSheetByName(COMPLETED_SHEET_NAME);
  if (!targetSheet) {
    ss.toast(`ã‚¨ãƒ©ãƒ¼: ã‚·ãƒ¼ãƒˆ "${COMPLETED_SHEET_NAME}" ãŒã‚ã‚Šã¾ã›ã‚“`, 'ã‚¨ãƒ©ãƒ¼');
    sourceSheet.getRange(row, 1).setValue(false);
    return;
  }
  try {
    const targetRow = 2;
    targetSheet.insertRowBefore(targetRow);
    const lastCol = sourceSheet.getLastColumn();
    ensureSheetColumns(targetSheet, lastCol + 1);

    const sourceRange = sourceSheet.getRange(row, 1, 1, lastCol);
    sourceRange.copyTo(targetSheet.getRange(targetRow, 1));
    targetSheet.getRange(targetRow, 1).setValue(true); // ãƒã‚§ãƒƒã‚¯æ¸ˆã¿ã«ã™ã‚‹
    targetSheet.getRange(targetRow, lastCol + 1).setValue(new Date());
    
    sourceSheet.deleteRow(row);
    ss.toast('ã‚¿ã‚¹ã‚¯ã‚’å®Œäº†ã‚·ãƒ¼ãƒˆã¸ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã—ã¾ã—ãŸ', 'å®Œäº†');
  } catch (e) {
    ss.toast(`ç§»å‹•ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'ã‚¨ãƒ©ãƒ¼');
  }
}

function archiveCompletedTask(sheet, row) {
  try {
    const sourceRange = sheet.getRange(row, 1, 1, TASK_AREA_LAST_COL);
    const archiveRangeWidth = TASK_AREA_LAST_COL; 
    const insertRange = sheet.getRange(ARCHIVE_START_ROW, ARCHIVE_START_COL, 1, archiveRangeWidth);
    insertRange.insertCells(SpreadsheetApp.Dimension.ROWS);
    
    ensureSheetColumns(sheet, 24); // Xåˆ—(24)ã¾ã§ç¢ºä¿
    sourceRange.copyTo(sheet.getRange(ARCHIVE_START_ROW, ARCHIVE_START_COL));
    sheet.getRange(ARCHIVE_START_ROW, ARCHIVE_START_COL).setValue(true); // ãƒã‚§ãƒƒã‚¯æ¸ˆã¿ã«ã™ã‚‹
    sheet.getRange(ARCHIVE_START_ROW, 24).setValue(new Date()); // Xåˆ—ã«ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
    
    sourceRange.deleteCells(SpreadsheetApp.Dimension.ROWS);
    SpreadsheetApp.getActiveSpreadsheet().toast('å®Œäº†ã‚¿ã‚¹ã‚¯ã‚’ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã—ã¾ã—ãŸ', 'å®Œäº†');
  } catch (e) {
    SpreadsheetApp.getActiveSpreadsheet().toast(`ç§»å‹•ä¸­ã«ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'ã‚¨ãƒ©ãƒ¼');
  }
}

function createProjectSheets() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const pSheet = ss.getSheetByName(PROJECT_SHEET_NAME);
  if (!pSheet) return;
  const vals = pSheet.getRange(2, 1, pSheet.getLastRow()-1, 1).getValues();
  vals.forEach(r => { 
    if(r[0] && !ss.getSheetByName(String(r[0]).trim())) {
      createNewSheet(String(r[0]).trim());
    }
  });
}

function syncTasksToCalendar() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const taskSheet = ss.getSheetByName(TASK_SHEET_NAME);
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  if (!taskSheet || !settingsSheet) return;
  const calMap = getCalendarMap(settingsSheet);
  const lastRow = taskSheet.getLastRow();
  if (lastRow < TASK_START_ROW) return;

  const range = taskSheet.getRange(TASK_START_ROW, 1, lastRow - TASK_START_ROW + 1, taskSheet.getLastColumn());
  const vals = range.getValues();
  const ids = [];

  for (let i=0; i<vals.length; i++) {
    const row = vals[i];
    const [task, start, dur, type, eid, tid] = [
      row[COL_TASK_NAME-1], row[COL_START_TIME-1], row[COL_DURATION-1],
      row[COL_CAL_TYPE-1], row[COL_EVENT_ID-1], row[COL_TASK_ID-1]
    ];
    if (!eid && task && start && dur && type && tid && calMap[type]) {
      try {
        const cal = CalendarApp.getCalendarById(calMap[type]);
        if (cal) {
          const end = new Date(start);
          end.setMinutes(end.getMinutes() + Number(dur));
          const ev = cal.createEvent(task, start, end, { description: `ã‚¿ã‚¹ã‚¯ID: ${tid}\nProjectsè‡ªå‹•é€£æº` });
          ev.addPopupReminder(0);
          ids.push([ev.getId()]);
        } else { ids.push([eid]); }
      } catch(e) { ids.push([eid]); }
    } else { ids.push([eid]); }
  }
  if (ids.length) taskSheet.getRange(TASK_START_ROW, COL_EVENT_ID, ids.length, 1).setValues(ids);
  ss.toast('Tasksã‚·ãƒ¼ãƒˆåŒæœŸå®Œäº†', 'å®Œäº†');
}

function executeTasksAction() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const taskSheet = ss.getSheetByName(TASK_SHEET_NAME);
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  const calendarMap = getCalendarMap(settingsSheet);

  if (!taskSheet) return;

  const lastRow = taskSheet.getLastRow();
  if (lastRow < TASK_START_ROW) {
    ss.toast('å‡¦ç†å¯¾è±¡ã®ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“', 'å®Œäº†');
    return;
  }

  const MAX_CHECK_ROWS = 60;
  const processRows = Math.min(lastRow - TASK_START_ROW + 1, MAX_CHECK_ROWS);
  const range = taskSheet.getRange(TASK_START_ROW, 1, processRows, TASK_AREA_LAST_COL);
  const values = range.getValues();
  
  let syncCount = 0;
  let idUpdated = false;

  for (let i = 0; i < values.length; i++) {
    const rowData = values[i];
    if (!rowData.some(c => c !== '')) continue;

    const taskName  = rowData[COL_TASK_NAME - 1];
    const startTime = rowData[COL_START_TIME - 1];
    const duration  = rowData[COL_DURATION - 1];
    const memo      = rowData[COL_MEMO - 1];
    const calType   = rowData[COL_CAL_TYPE - 1];
    const eventId   = rowData[COL_EVENT_ID - 1];
    let taskId    = rowData[COL_TASK_ID - 1];

    if (!taskId) {
        taskId = Utilities.getUuid().split('-')[0];
        values[i][COL_TASK_ID - 1] = taskId;
        idUpdated = true;
    }

    if (!eventId && taskName && startTime && taskId) {
      if (calType && calendarMap[calType]) {
        try {
          const calendar = CalendarApp.getCalendarById(calendarMap[calType]);
          if (calendar) {
            const startDate = new Date(startTime);
            const endDate = new Date(startDate);
            const dur = Number(duration) || 30;
            endDate.setMinutes(endDate.getMinutes() + dur);
            
            const desc = `${memo || ''}\n\nã‚¿ã‚¹ã‚¯ID: ${taskId}\nã‚·ãƒ¼ãƒˆé€£æº`;
            const event = calendar.createEvent(taskName, startDate, endDate, {
              description: desc
            });
            event.addPopupReminder(0);
            
            values[i][COL_EVENT_ID - 1] = event.getId();
            syncCount++;
            idUpdated = true;
          }
        } catch (e) { console.error(`Sync Error: ${e.message}`); }
      }
    }
  }

  if (idUpdated) {
    range.setValues(values);
  }

  let moveCount = 0;
  
  for (let i = values.length - 1; i >= 0; i--) {
    const rowData = values[i];
    if (!rowData.some(c => c !== '')) continue;

    const rawProjectName = rowData[COL_PROJECT_NAME - 1];
    const taskName = rowData[COL_TASK_NAME - 1];

    if (rawProjectName && taskName) {
      const projectName = String(rawProjectName).trim();
      
      if (!EXCLUDED_SHEETS.includes(projectName)) {
        const targetSheet = ss.getSheetByName(projectName);
        
        if (targetSheet) {
          try {
            const targetRow = 29;
            targetSheet.insertRowBefore(targetRow);
            targetSheet.getRange(targetRow, 1, 1, rowData.length).setValues([rowData]);
            taskSheet.deleteRow(TASK_START_ROW + i);
            values.splice(i, 1);
            moveCount++;
          } catch (e) { console.error(`Move Error: ${e.message}`); }
        }
      }
    }
  }

  sortAndWriteBack(taskSheet, TASK_START_ROW, values);

  let msg = `å®Œäº†: `;
  if (syncCount > 0) msg += `${syncCount}ä»¶åŒæœŸ, `;
  if (moveCount > 0) msg += `${moveCount}ä»¶è»¢é€, `;
  msg += `ä¸¦ã³æ›¿ãˆã¾ã—ãŸ`;
  ss.toast(msg, 'å®Œäº†');
}

// --- ä¿®æ­£ç‰ˆ: ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ä»˜ãåŒæœŸé–¢æ•° ---
function syncAndSortProjectSheet(sheet) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  const calendarMap = getCalendarMap(settingsSheet);

  console.log(`[Sync] Calendar Map Keys: ${Object.keys(calendarMap).join(', ')}`);

  const lastRow = sheet.getLastRow();
  const numRows = lastRow - PROJECT_TASK_START_ROW + 1;
  if (numRows < 1) return;

  const range = sheet.getRange(PROJECT_TASK_START_ROW, 1, numRows, TASK_AREA_LAST_COL);
  let values = range.getValues();

  let syncCount = 0;
  let updateCount = 0;
  let warningMsg = '';

  for (let i = 0; i < values.length; i++) {
    const rowData = values[i];
    if (!rowData.some(c => c !== '')) continue;

    const taskName = rowData[COL_TASK_NAME - 1];
    let startTime = rowData[COL_START_TIME - 1]; // Let as variable for casting
    const duration = rowData[COL_DURATION - 1];
    const memo = rowData[COL_MEMO - 1];
    const calType = rowData[COL_CAL_TYPE - 1];
    const eventId = rowData[COL_EVENT_ID - 1];
    let taskId = rowData[COL_TASK_ID - 1];

    if (!taskId && taskName) {
      taskId = Utilities.getUuid().split('-')[0];
      rowData[COL_TASK_ID - 1] = taskId;
    }

    if (taskName && startTime) {
      if (!calType) continue;

      const trimmedType = String(calType).trim();
      const calId = calendarMap[trimmedType];
      
      console.log(`[Sync] Row ${i+PROJECT_TASK_START_ROW}: ${taskName} (${trimmedType}) -> ${calId ? 'Found' : 'Not Found'}`);

      if (!calId) {
        if (!warningMsg) warningMsg = `è¨­å®šã«ãªã„ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ç¨®åˆ¥: ${trimmedType}`;
        continue;
      }

      try {
        const cal = CalendarApp.getCalendarById(calId);
        if (cal) {
          // Dateå‹å¤‰æ›ã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
          let startDate = startTime;
          if (typeof startDate === 'string' || !(startDate instanceof Date)) {
             startDate = new Date(startTime);
          }
          if (isNaN(startDate.getTime())) {
            console.warn(`[Sync] Invalid Date for ${taskName}: ${startTime}`);
            continue;
          }

          const endDate = new Date(startDate);
          const d = Number(duration) || 30;
          endDate.setMinutes(endDate.getMinutes() + d);

          // ãƒ¡ãƒ¢æ¬„åŒæœŸç”¨èª¬æ˜æ–‡
          const desc = `${memo || ''}\n\nã‚¿ã‚¹ã‚¯ID: ${taskId}\nã‚·ãƒ¼ãƒˆé€£æº`;

          if (!eventId) {
            // æ–°è¦
            console.log(`[Sync] Creating new event for ${taskName}`);
            const ev = cal.createEvent(taskName, startDate, endDate, { description: desc });
            ev.addPopupReminder(0);
            rowData[COL_EVENT_ID - 1] = ev.getId();
            syncCount++;
          } else {
            // æ›´æ–°ãƒã‚§ãƒƒã‚¯
            try {
               const ev = cal.getEventById(eventId);
               if (ev) {
                 const evStart = ev.getStartTime();
                 const evEnd = ev.getEndTime();
                 const evNote = ev.getDescription() || '';

                 let needUpdate = false;
                 
                 // æ™‚é–“æ¯”è¼ƒ (1åˆ†ä»¥ä¸Šã®ã‚ºãƒ¬)
                 if (Math.abs(evStart.getTime() - startDate.getTime()) > 60000) {
                     console.log(`[Sync] Start time diff: Ev=${evStart} vs Sheet=${startDate}`);
                     needUpdate = true;
                 }
                 if (Math.abs(evEnd.getTime() - endDate.getTime()) > 60000) {
                     console.log(`[Sync] End time diff`);
                     needUpdate = true;
                 }
                 
                 // èª¬æ˜æ–‡æ¯”è¼ƒ
                 // æ”¹è¡Œã‚³ãƒ¼ãƒ‰æ­£è¦åŒ–ãªã©ã‚’å…¥ã‚ŒãŸã»ã†ãŒè‰¯ã„ãŒã€ã¾ãšã¯å˜ç´”æ¯”è¼ƒ
                 if (evNote !== desc) {
                     console.log(`[Sync] Desc diff for ${taskName}`);
                     ev.setDescription(desc);
                     updateCount++;
                 }

                 if (needUpdate) {
                   console.log(`[Sync] Updating time for ${taskName}`);
                   ev.setTime(startDate, endDate);
                   // Descæ›´æ–°ã§ã‚«ã‚¦ãƒ³ãƒˆã—ã¦ã„ãªã‘ã‚Œã°ã‚«ã‚¦ãƒ³ãƒˆ
                   if (evNote === desc) updateCount++;
                 }
               } else {
                 console.warn(`[Sync] Event not found: ${eventId}`);
               }
            } catch(e) {
               console.warn(`[Sync] Event update error: ${eventId}, ${e.message}`);
            }
          }
        }
      } catch (e) { console.error(e); }
    }
  }

  sortAndWriteBack(sheet, PROJECT_TASK_START_ROW, values);

  let msg = [];
  if (syncCount > 0) msg.push(`${syncCount}ä»¶æ–°è¦`);
  if (updateCount > 0) msg.push(`${updateCount}ä»¶æ›´æ–°`);
  if (warningMsg) msg.push(`âš ${warningMsg}`);
  if (msg.length === 0) msg.push('å¤‰æ›´ãªã—');
  msg.push('ä¸¦ã³æ›¿ãˆå®Œäº†');
  
  ss.toast(msg.join(', '), 'å®Œäº†');
}

function sortAndWriteBack(sheet, startRow, values) {
  const withDate = [];
  const withoutDate = [];

  for (let i = 0; i < values.length; i++) {
    const rowData = values[i];
    if (!rowData.some(c => c !== '')) continue;

    const startTime = rowData[COL_START_TIME - 1];
    if (startTime instanceof Date && !isNaN(startTime)) {
      withDate.push(rowData);
    } else {
      withoutDate.push(rowData);
    }
  }

  const priorityMap = { 'ç·Šæ€¥': 4, 'é«˜ã„': 3, 'ä¸­': 2, 'ä½ã„': 1 };
  const getPriorityScore = (p) => priorityMap[p] || 0;

  const sortFunc = (a, b) => {
    const priA = getPriorityScore(a[COL_PRIORITY - 1]);
    const priB = getPriorityScore(b[COL_PRIORITY - 1]);
    const durA = Number(a[COL_DURATION - 1]) || 0;
    const durB = Number(b[COL_DURATION - 1]) || 0;
    if (priA !== priB) return priB - priA; 
    return durA - durB;
  };

  withDate.sort((a, b) => {
    const dateA = a[COL_START_TIME - 1].getTime();
    const dateB = b[COL_START_TIME - 1].getTime();
    if (dateA !== dateB) return dateA - dateB; 
    return sortFunc(a, b);
  });
  withoutDate.sort(sortFunc);

  const emptyRow = new Array(TASK_AREA_LAST_COL).fill('');
  let resultValues = [];
  if (withDate.length > 0) resultValues = resultValues.concat(withDate);
  if (withoutDate.length > 0) resultValues = resultValues.concat(withoutDate);

  const currentLastRow = sheet.getLastRow();
  const rowsToClear = Math.max(currentLastRow - startRow + 1, values.length);
  if (rowsToClear > 0) {
    sheet.getRange(startRow, 1, rowsToClear, TASK_AREA_LAST_COL).clearContent();
  }
  
  if (resultValues.length > 0) {
    sheet.getRange(startRow, 1, resultValues.length, TASK_AREA_LAST_COL).setValues(resultValues);
  }
}

/**
 * ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‹ã‚‰Inboxã¸å–è¾¼ (é‡è¤‡ãƒã‚§ãƒƒã‚¯ä»˜ã)
 */
function importCalendarToInbox(settingsSheet, row) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let inboxSheet = ss.getSheetByName(CALENDAR_INBOX_SHEET_NAME);

  // ã‚·ãƒ¼ãƒˆãŒãªã‘ã‚Œã°ä½œæˆ (ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã‚’ã‚³ãƒ”ãƒ¼æ¨å¥¨ã ãŒã€ç°¡æ˜“ä½œæˆ)
  if (!inboxSheet) {
    const templateSheet = ss.getSheetByName(TASK_SHEET_NAME); // ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚’ãƒ†ãƒ³ãƒ—ãƒ¬ã«
    if (templateSheet) {
      inboxSheet = templateSheet.copyTo(ss).setName(CALENDAR_INBOX_SHEET_NAME);
      // ä¸­èº«ã‚¯ãƒªã‚¢
      const lastRow = inboxSheet.getLastRow();
      if (lastRow >= TASK_START_ROW) {
         inboxSheet.getRange(TASK_START_ROW, 1, lastRow - TASK_START_ROW + 1, inboxSheet.getLastColumn()).clearContent();
      }
      inboxSheet.getRange('A3').setValue(false).insertCheckbox(); // å®Ÿè¡Œãƒœã‚¿ãƒ³ (A3)
      inboxSheet.getRange('B3').setValue('ã‚¿ã‚¹ã‚¯æŒ¯ã‚Šåˆ†ã‘');       // ãƒ©ãƒ™ãƒ« (B3)
      // ä»–ã®ä½™è¨ˆãªãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ç­‰ã¯å‰Šé™¤
      inboxSheet.getRange('A1:B2').clearContent().removeCheckboxes();
    } else {
      inboxSheet = ss.insertSheet(CALENDAR_INBOX_SHEET_NAME);
      // ãƒ˜ãƒƒãƒ€ãƒ¼ç°¡æ˜“ä½œæˆ
      inboxSheet.getRange('A3').insertCheckbox();
      inboxSheet.getRange('B3').setValue('ã‚¿ã‚¹ã‚¯æŒ¯ã‚Šåˆ†ã‘');
      inboxSheet.appendRow(['', '', '', '', '', '', '', '', '', '']); // 1-3è¡Œç›®èª¿æ•´
      inboxSheet.getRange(4, 1, 1, 10).setValues([['', 'ã‚¿ã‚¹ã‚¯å', 'é–‹å§‹æ—¥æ™‚', 'å„ªå…ˆåº¦', 'æ‰€è¦æ™‚é–“', 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå', '', '', 'CalType', 'EventID']]);
    }
  }

  // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼IDå–å¾—
  const calIdInfo = getCalendarInfoFromRow(settingsSheet, row);
  if (!calIdInfo.id) {
    ss.toast('æœ‰åŠ¹ãªã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼IDãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 'ã‚¨ãƒ©ãƒ¼');
    return;
  }
  
  const calName = calIdInfo.name;
  const calId = calIdInfo.id;
  const cal = CalendarApp.getCalendarById(calId);
  if (!cal) {
    ss.toast(`ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–å¾—å¤±æ•—: ${calId}`, 'ã‚¨ãƒ©ãƒ¼');
    return;
  }

  // é‡è¤‡ãƒã‚§ãƒƒã‚¯ç”¨IDãƒªã‚¹ãƒˆåé›†
  const existingEventIds = new Set();
  const allSheets = ss.getSheets();
  const targetSheetNames = [TASK_SHEET_NAME, CALENDAR_INBOX_SHEET_NAME, ...allSheets.map(s => s.getName()).filter(n => !EXCLUDED_SHEETS.includes(n))];
  
  targetSheetNames.forEach(sName => {
     const s = ss.getSheetByName(sName);
     if (!s) return;
     const startR = (sName === TASK_SHEET_NAME || sName === CALENDAR_INBOX_SHEET_NAME) ? TASK_START_ROW : PROJECT_TASK_START_ROW;
     const lastR = s.getLastRow();
     if (lastR >= startR) {
        const ids = s.getRange(startR, COL_EVENT_ID, lastR - startR + 1, 1).getValues().flat();
        ids.forEach(id => { if(id) existingEventIds.add(String(id)); });
     }
  });

  // ã‚¤ãƒ™ãƒ³ãƒˆå–å¾— (å‰å¾Œ1é€±é–“? ãƒ¦ãƒ¼ã‚¶è¦æœ›ã¯"1é€±é–“åˆ†" -> ä»Šæ—¥ã‹ã‚‰1é€±é–“ã¨ã™ã‚‹)
  const startTime = new Date();
  startTime.setHours(0,0,0,0);
  const endTime = new Date();
  endTime.setDate(endTime.getDate() + 7);

  const events = cal.getEvents(startTime, endTime);
  const newTasks = [];

  events.forEach(evt => {
    const eid = evt.getId();
    if (existingEventIds.has(eid)) return; // é‡è¤‡ã‚¹ã‚­ãƒƒãƒ—

    const title = evt.getTitle();
    const start = evt.getStartTime();
    const end = evt.getEndTime();
    const duration = Math.round((end.getTime() - start.getTime()) / (1000 * 60));
    
    // [Check, TaskName, Start, Priority, Duration, ProjectName, ..., CalType, EventID]
    // A=1, B=2, C=3, D=4, E=5, F=6, ..., I=9, J=10
    const rowData = new Array(12).fill('');
    rowData[COL_TASK_NAME - 1] = title;
    rowData[COL_START_TIME - 1] = start;
    rowData[COL_DURATION - 1] = duration;
    rowData[COL_CAL_TYPE - 1] = calName; // è¨­å®šã‚·ãƒ¼ãƒˆã®åå‰
    rowData[COL_EVENT_ID - 1] = eid;
    // TaskIDã¯ã¾ã ä½œã‚‰ãªã„ï¼ˆæŒ¯ã‚Šåˆ†ã‘æ™‚ã«ç”Ÿæˆï¼‰
    
    newTasks.push(rowData);
  });

  if (newTasks.length > 0) {
    const startRow = inboxSheet.getLastRow() + 1;
    // TASK_START_ROWä»¥ä¸Šã§ã‚ã‚‹ã“ã¨ã‚’ä¿è¨¼
    const writeRow = Math.max(startRow, TASK_START_ROW);
    inboxSheet.getRange(writeRow, 1, newTasks.length, newTasks[0].length).setValues(newTasks);
    ss.toast(`${newTasks.length}ä»¶ã®äºˆå®šã‚’å–ã‚Šè¾¼ã¿ã¾ã—ãŸ`, 'å®Œäº†');
  } else {
    ss.toast('æ–°è¦ã®äºˆå®šã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ', 'å®Œäº†');
  }
}

/**
 * Inboxã‚¿ã‚¹ã‚¯ã‚’æŒ¯ã‚Šåˆ†ã‘
 */
function distributeInboxTasks() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const inboxSheet = ss.getSheetByName(CALENDAR_INBOX_SHEET_NAME);
  if (!inboxSheet) return;

  const lastRow = inboxSheet.getLastRow();
  if (lastRow < TASK_START_ROW) {
    ss.toast('æŒ¯ã‚Šåˆ†ã‘å¯¾è±¡ãŒã‚ã‚Šã¾ã›ã‚“', 'å®Œäº†');
    return;
  }

  const range = inboxSheet.getRange(TASK_START_ROW, 1, lastRow - TASK_START_ROW + 1, TASK_AREA_LAST_COL);
  const values = range.getValues();
  const taskInputSheet = ss.getSheetByName(TASK_SHEET_NAME);
  
  let moveToProjectCount = 0;
  let moveToInputCount = 0;
  const rowsToDelete = [];

  // ä¸‹ã‹ã‚‰å‡¦ç†ã—ã¦å‰Šé™¤ã™ã‚‹ãŸã‚
  for (let i = values.length - 1; i >= 0; i--) {
    const rowData = values[i];
    if (!rowData.some(c => c !== '')) continue; // ç©ºè¡Œã‚¹ã‚­ãƒƒãƒ—

    const taskName = rowData[COL_TASK_NAME - 1];
    if (!taskName) continue; // ã‚¿ã‚¹ã‚¯åãªã—ã¯ç„¡è¦–

    // ã‚¿ã‚¹ã‚¯IDç”Ÿæˆ (ã¾ã ãªã‘ã‚Œã°)
    if (!rowData[COL_TASK_ID - 1]) {
       rowData[COL_TASK_ID - 1] = Utilities.getUuid().split('-')[0];
    }

    const rawProjectName = rowData[COL_PROJECT_NAME - 1];
    const projectName = String(rawProjectName || '').trim();
    let moved = false;

    // 1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåãŒã‚ã‚Šã€ã‹ã¤æœ‰åŠ¹ãªã‚·ãƒ¼ãƒˆãŒã‚ã‚‹å ´åˆ -> ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã¸
    if (projectName && !EXCLUDED_SHEETS.includes(projectName)) {
      const targetSheet = ss.getSheetByName(projectName);
      if (targetSheet) {
        try {
          const targetRow = PROJECT_TASK_START_ROW;
          targetSheet.insertRowBefore(targetRow);
          targetSheet.getRange(targetRow, 1, 1, rowData.length).setValues([rowData]);
          moved = true;
          moveToProjectCount++;
        } catch (e) {
          console.warn(`Move to project failed: ${projectName}`, e);
        }
      }
    }

    // 2. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåãŒãªã„ã€ã¾ãŸã¯ã‚·ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ -> ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã¸
    if (!moved && taskInputSheet) {
        try {
          const targetRow = TASK_START_ROW;
          taskInputSheet.insertRowBefore(targetRow);
          taskInputSheet.getRange(targetRow, 1, 1, rowData.length).setValues([rowData]);
          moved = true;
          moveToInputCount++;
        } catch (e) {
          console.warn(`Move to input failed`, e);
        }
    }

    if (moved) {
      // å‰Šé™¤å¯¾è±¡ã¨ã—ã¦ãƒãƒ¼ã‚¯ (Inboxã‹ã‚‰ã¯æ¶ˆã™)
      inboxSheet.deleteRow(TASK_START_ROW + i);
    }
  }

  // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆå´ãƒ»ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆå´ã®ä¸¦ã³æ›¿ãˆã‚’è¡Œã†ã®ãŒç†æƒ³ã ãŒã€
  // ä»¶æ•°ãŒå¤šã„ã¨é‡ããªã‚‹ã®ã§ã€ä»Šå›ã¯ã€Œè»¢é€ã€ã«ç•™ã‚ã‚‹ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå„ã‚·ãƒ¼ãƒˆã§æ›´æ–°ãƒœã‚¿ãƒ³ã‚’æŠ¼ã›ã°ä¸¦ã¶ï¼‰
  // ã‚‚ã—è¦æœ›ãŒã‚ã‚Œã°ã“ã“ã§ sortAndWriteBack ã‚’å„ã‚·ãƒ¼ãƒˆã«å¯¾ã—ã¦å‘¼ã¶ã€‚
  
  ss.toast(`${moveToProjectCount}ä»¶ã‚’ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¸ã€${moveToInputCount}ä»¶ã‚’ã‚¿ã‚¹ã‚¯å…¥åŠ›ã¸ç§»å‹•ã—ã¾ã—ãŸ`, 'å®Œäº†');
}

/**
 * è¨­å®šã‚·ãƒ¼ãƒˆã®æŒ‡å®šè¡Œã‹ã‚‰ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æƒ…å ±ã‚’å–å¾—
 */
function getCalendarInfoFromRow(sheet, row) {
  const name = sheet.getRange(row, SETTINGS_NAME_COL).getValue();
  let id = sheet.getRange(row, SETTINGS_ID_COL).getValue();
  
  if (id && id.includes('calendar.google.com')) {
      const match = id.match(/src=([^&]+)/);
      if (match) id = decodeURIComponent(match[1]);
      else {
        const cidMatch = id.match(/cid=([^&]+)/);
        if (cidMatch) id = decodeURIComponent(cidMatch[1]);
      }
  }
  return { name, id };
}

/**
 * 
 * --- ã‚¿ã‚¹ã‚¯é›†è¨ˆãƒ»å¯è¦–åŒ–æ©Ÿèƒ½ ---
 * 
 */

/**
 * å®Œäº†ã‚¿ã‚¹ã‚¯ã‚’é›†è¨ˆã—ã¦ã‚°ãƒ©ãƒ•åŒ–ã™ã‚‹ (ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆä¿®æ­£: 2è¡Œç›®ã¾ã§å…¥åŠ›ã‚¨ãƒªã‚¢)
 */
/**
 * å®Œäº†ã‚¿ã‚¹ã‚¯ã‚’é›†è¨ˆã—ã¦ã‚°ãƒ©ãƒ•åŒ–ã™ã‚‹ (ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãƒ»ã‚°ãƒ©ãƒ•å„ªå…ˆç‰ˆ v3.1 - Tagåˆ—ä¿®æ­£)
 */
function aggregateAndVisualize() {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let analysisSheet = ss.getSheetByName(ANALYSIS_SHEET_NAME);

    if (!analysisSheet) {
        analysisSheet = ss.insertSheet(ANALYSIS_SHEET_NAME);
        analysisSheet.setTabColor('#FF9800');
    }

    // --- UIã‚¨ãƒªã‚¢ (Rows 1-2) ---
    const a1Rule = analysisSheet.getRange('A1').getDataValidation();
    if (!a1Rule) analysisSheet.getRange('A1').insertCheckboxes();

    analysisSheet.getRange('B1').setValue('é›†è¨ˆå®Ÿè¡Œ(ON)').setFontWeight('bold');
    analysisSheet.getRange('C1').setValue('é›†è¨ˆé–‹å§‹æ—¥:').setHorizontalAlignment('right');
    analysisSheet.getRange('C2').setValue('é›†è¨ˆçµ‚äº†æ—¥:').setHorizontalAlignment('right');

    // ã‚¹ã‚¿ã‚¤ãƒ«é©ç”¨
    analysisSheet.getRange('A1:D2').setBackground('#FFF3E0').setBorder(true, true, true, true, null, null);

    // --- æœŸé–“å–å¾— ---
    let startDate = analysisSheet.getRange('D1').getValue();
    let endDate = analysisSheet.getRange('D2').getValue();
    const today = new Date();

    if (!(startDate instanceof Date)) {
        startDate = new Date(today.getFullYear(), today.getMonth(), 1);
        analysisSheet.getRange('D1').setValue(startDate);
    }
    if (!(endDate instanceof Date)) {
        endDate = new Date(today.getFullYear(), today.getMonth() + 1, 0);
        analysisSheet.getRange('D2').setValue(endDate);
    }

    startDate.setHours(0, 0, 0, 0);
    endDate.setHours(23, 59, 59, 999);

    // --- å…¨ã‚¯ãƒªã‚¢ (Row 4ä»¥é™) ---
    const lastRow = analysisSheet.getLastRow();
    const lastCol = Math.max(analysisSheet.getLastColumn(), 20);
    if (lastRow >= 4) {
        analysisSheet.getRange(4, 1, lastRow - 3, lastCol).clearContent().clearFormat();
    }

    // ä»¥å‰ã®ã‚°ãƒ©ãƒ•å‰Šé™¤
    const charts = analysisSheet.getCharts();
    charts.forEach(c => analysisSheet.removeChart(c));

    // --- ãƒ‡ãƒ¼ã‚¿åé›† ---
    const allData = [];
    const COL_TAG_INDEX = 6; // Gåˆ— (Index 6)

    // 1. å®Œäº†ã‚¿ã‚¹ã‚¯ã‚·ãƒ¼ãƒˆ
    const completedSheet = ss.getSheetByName(COMPLETED_SHEET_NAME);
    if (completedSheet) {
        const lastR = completedSheet.getLastRow();
        if (lastR >= 2) {
            const range = completedSheet.getRange(2, 1, lastR - 1, 20);
            const values = range.getValues();
            values.forEach(row => {
                const taskName = row[COL_TASK_NAME - 1];
                const duration = row[COL_DURATION - 1];
                const priority = row[COL_PRIORITY - 1];
                const project = row[COL_PROJECT_NAME - 1] || 'æœªåˆ†é¡';
                const memo = row[COL_MEMO - 1];

                // Tagã¯Gåˆ—(Index 6)
                const tag = row[COL_TAG_INDEX] || '';

                let completionDate = null;
                for (let i = 12; i < row.length; i++) {
                    if (row[i] instanceof Date) { completionDate = row[i]; break; }
                }

                if (taskName && completionDate) {
                    allData.push({
                        date: completionDate,
                        project: project,
                        tag: tag,
                        task: taskName,
                        duration: Number(duration) || 0,
                        priority: priority,
                        memo: memo
                    });
                }
            });
        }
    }

    // 2. ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–
    const allSheets = ss.getSheets();
    allSheets.forEach(sheet => {
        const sName = sheet.getName();
        if (!EXCLUDED_SHEETS.includes(sName) && sName !== ANALYSIS_SHEET_NAME) {
            const lastR = sheet.getLastRow();
            if (lastR >= ARCHIVE_START_ROW) {
                const numRows = lastR - ARCHIVE_START_ROW + 1;
                const range = sheet.getRange(ARCHIVE_START_ROW, ARCHIVE_START_COL, numRows, 12);
                const values = range.getValues();
                values.forEach(row => {
                    // M=0, N=1, O=2, P=3, Q=4, R=5, S(Tag)=6
                    const taskName = row[1]; // N
                    const priority = row[3]; // P
                    const duration = row[4]; // Q
                    const project = row[5] || sName; // R
                    const tag = row[6] || '';    // S
                    const completionDate = row[11]; // X

                    if (taskName && completionDate instanceof Date) {
                        allData.push({
                            date: completionDate,
                            project: project || sName,
                            tag: tag,
                            task: taskName,
                            duration: Number(duration) || 0,
                            priority: priority,
                            memo: row[7]
                        });
                    }
                });
            }
        }
    });

    // --- ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚° & ã‚½ãƒ¼ãƒˆ ---
    const filteredData = allData.filter(d => {
        return d.date.getTime() >= startDate.getTime() && d.date.getTime() <= endDate.getTime();
    });

    // é›†è¨ˆå‡¦ç†
    const projMap = {};
    const tagMap = {};
    const dailyMap = {};

    filteredData.forEach(d => {
        // Project
        const pName = d.project;
        if (!projMap[pName]) projMap[pName] = 0;
        projMap[pName] += d.duration;

        // Tag (ç©ºã®å ´åˆã¯é›†è¨ˆã—ãªã„)
        const tName = d.tag;
        if (tName && String(tName).trim() !== '' && tName !== '-') {
            if (!tagMap[tName]) tagMap[tName] = 0;
            tagMap[tName] += d.duration;
        }

        // Daily
        const dayStr = Utilities.formatDate(d.date, Session.getScriptTimeZone(), 'MM/dd');
        if (!dailyMap[dayStr]) dailyMap[dayStr] = 0;
        dailyMap[dayStr] += d.duration;
    });

    // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ä½œæˆ
    const projRanking = Object.entries(projMap).sort((a, b) => b[1] - a[1]);
    const tagRanking = Object.entries(tagMap).sort((a, b) => b[1] - a[1]);
    const dailyTrend = Object.entries(dailyMap).sort((a, b) => a[0].localeCompare(b[0]));

    // --- ãƒ©ãƒ³ã‚­ãƒ³ã‚°è¡¨ç¤º (Items: A4~E20) ---

    // 1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ©ãƒ³ã‚­ãƒ³ã‚°
    analysisSheet.getRange('A4').setValue('â–  ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆ¥ æ™‚é–“ãƒ©ãƒ³ã‚­ãƒ³ã‚°').setFontWeight('bold').setFontSize(11);
    analysisSheet.getRange('A5:C5').setValues([['é †ä½', 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå', 'æ™‚é–“(åˆ†)']])
        .setBackground('#FFCC80') // ã‚ªãƒ¬ãƒ³ã‚¸èƒŒæ™¯
        .setFontWeight('bold')
        .setHorizontalAlignment('center');

    if (projRanking.length > 0) {
        const pOut = projRanking.map((p, i) => [i + 1, p[0], p[1]]);
        analysisSheet.getRange(6, 1, pOut.length, 3).setValues(pOut);
        // ä¸Šä½3ä½ã«è‰²ä»˜ã‘
        if (pOut.length >= 1) analysisSheet.getRange(6, 1, 1, 3).setBackground('#FFF8E1');
    }

    // 2. ã‚¿ã‚°ãƒ©ãƒ³ã‚­ãƒ³ã‚°
    analysisSheet.getRange('E4').setValue('â–  ã‚¿ã‚°åˆ¥ æ™‚é–“ãƒ©ãƒ³ã‚­ãƒ³ã‚°').setFontWeight('bold').setFontSize(11);
    analysisSheet.getRange('E5:G5').setValues([['é †ä½', 'ã‚¿ã‚°å', 'æ™‚é–“(åˆ†)']])
        .setBackground('#B3E5FC') // æ°´è‰²èƒŒæ™¯
        .setFontWeight('bold')
        .setHorizontalAlignment('center');

    if (tagRanking.length > 0) {
        const tOut = tagRanking.map((t, i) => [i + 1, t[0], t[1]]);
        analysisSheet.getRange(6, 5, tOut.length, 3).setValues(tOut);
    }

    // --- ã‚°ãƒ©ãƒ•ä½œæˆ (I4 Area) ---

    // Project Pie
    if (projRanking.length > 0) {
        const limit = Math.min(projRanking.length, 10);
        const chart1 = analysisSheet.newChart()
            .setChartType(Charts.ChartType.PIE)
            .addRange(analysisSheet.getRange(5, 2, limit + 1, 2)) // B5:C[LIMIT]
            .setPosition(4, 9, 0, 0) // I4
            .setOption('title', 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆ¥ å‰²åˆ')
            .setOption('width', 380)
            .setOption('height', 280)
            .build();
        analysisSheet.insertChart(chart1);
    }

    // Tag Pie
    if (tagRanking.length > 0) {
        const limit = Math.min(tagRanking.length, 10);
        const chart2 = analysisSheet.newChart()
            .setChartType(Charts.ChartType.PIE)
            .addRange(analysisSheet.getRange(5, 6, limit + 1, 2)) // F5:G[LIMIT]
            .setPosition(4, 13, 0, 0) // M4
            .setOption('title', 'ã‚¿ã‚°åˆ¥ å‰²åˆ')
            .setOption('width', 380)
            .setOption('height', 280)
            .build();
        analysisSheet.insertChart(chart2);
    }

    // Daily Chart
    if (dailyTrend.length > 0) {
        const dOut = [['æ—¥ä»˜', 'æ™‚é–“(åˆ†)'], ...dailyTrend];
        analysisSheet.getRange(1, 26, dOut.length, 2).setValues(dOut); // Z1

        const chart3 = analysisSheet.newChart()
            .setChartType(Charts.ChartType.COLUMN)
            .addRange(analysisSheet.getRange(1, 26, dOut.length, 2))
            .setPosition(22, 9, 0, 0) // I22
            .setOption('title', 'æ—¥åˆ¥ ä½œæ¥­æ™‚é–“æ¨ç§»')
            .setOption('width', 750)
            .setOption('height', 300)
            .build();
        analysisSheet.insertChart(chart3);
    }

    // --- ã‚¿ã‚¹ã‚¯ä¸€è¦§ (Rankingã®ä¸‹) ---
    const maxRankLen = Math.max(projRanking.length, tagRanking.length);
    const listStartRow = Math.max(25, 6 + maxRankLen + 3);

    analysisSheet.getRange(listStartRow, 1).setValue('â–  å…¨ã‚¿ã‚¹ã‚¯å†…è¨³ (è©³ç´°)').setFontWeight('bold').setFontSize(12);
    const headers = ['å®Œäº†æ—¥', 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå', 'ã‚¿ã‚°', 'ã‚¿ã‚¹ã‚¯å', 'æ‰€è¦æ™‚é–“(åˆ†)', 'å„ªå…ˆåº¦', 'ãƒ¡ãƒ¢'];
    analysisSheet.getRange(listStartRow + 1, 1, 1, 7).setValues([headers])
        .setBackground('#E0E0E0')
        .setFontWeight('bold');

    filteredData.sort((a, b) => a.date - b.date);

    const listOut = filteredData.map(d => {
        let safeMemo = String(d.memo || '');
        if (safeMemo.length > 40) safeMemo = safeMemo.substring(0, 40) + '...';
        return [d.date, d.project, d.tag, d.task, d.duration, d.priority, safeMemo];
    });

    if (listOut.length > 0) {
        analysisSheet.getRange(listStartRow + 2, 1, listOut.length, 7).setValues(listOut);
        analysisSheet.getRange(listStartRow + 2, 1, listOut.length, 1).setNumberFormat('MM/dd HH:mm');
        if (listOut.length > 1) {
            analysisSheet.getRange(listStartRow + 2, 1, listOut.length, 7).applyRowBanding(SpreadsheetApp.BandingTheme.LIGHT_GREY);
        }
    }

    ss.toast(`é›†è¨ˆå®Œäº†: ${filteredData.length}ä»¶`, 'å®Œäº†');
}
